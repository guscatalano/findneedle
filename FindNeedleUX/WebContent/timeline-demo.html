<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Timeline Demo - Dual Monitor Setup</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: white;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
    

        /* Canvas area containing monitors */
        #canvas {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, #0d0d1a 0%, #1a1a2e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            gap: 8px;
        }
        
        /* Monitor frame styling */
        .monitor {
            position: absolute;
            background: #2a2a3e;
            border: 3px solid #444;
            border-radius: 8px;
            box-shadow: 
                0 0 0 2px #222,
                0 10px 30px rgba(0,0,0,0.5),
                inset 0 0 20px rgba(0,0,0,0.3);
        }
        
        .monitor::before {
            content: '';
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 15px;
            background: linear-gradient(to bottom, #333, #222);
            border-radius: 0 0 4px 4px;
        }
        
        .monitor-screen {
            position: relative;
            background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);
            overflow: hidden;
            border-radius: 4px;
            margin: 4px;
        }
        
        .monitor-label {
            position: absolute;
            top: 8px;
            left: 12px;
            font-size: 11px;
            opacity: 0.5;
            font-family: monospace;
            pointer-events: none;
            z-index: 10;
        }
        
        .monitor-resolution {
            position: absolute;
            top: 8px;
            right: 12px;
            font-size: 10px;
            opacity: 0.4;
            font-family: monospace;
            pointer-events: none;
            z-index: 10;
        }
        
        /* Boxes that move on screen */
        .box {
            position: absolute;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            transition: none;
            z-index: 20;
            pointer-events: none;
        }
        
        #box1 { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        #box2 { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        #box3 { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
        
        /* Timeline controls */
        #controls {
            background: #0f0f23;
            padding: 20px;
            border-top: 1px solid #333;
        }
        
        #timeline-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        #timeline {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 4px;
            cursor: pointer;
        }
        
        #timeline::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #667eea;
            border-radius: 50%;
            cursor: grab;
        }
        
        #timeline::-webkit-slider-thumb:active {
            cursor: grabbing;
        }
        
        #time-display {
            font-family: monospace;
            font-size: 16px;
            min-width: 100px;
        }
        
        .btn {
            background: #667eea;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }
        
        .btn:hover { background: #5a6fd6; }
        .btn.active { background: #f5576c; }
        
        #info {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 10px;
        }
        
        #speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        #speed-control label {
            font-size: 12px;
            opacity: 0.7;
        }
        
        #speed {
            width: 100px;
        }
        
        /* Mouse cursor */
        .mouse-cursor {
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: rgba(255,255,255,0.95);
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
        }
        /* Side panel docking */
        #side-panel {
            position: absolute;
            z-index: 1001;
            color: #fff;
            font-size: 13px;
            padding: 12px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
            background: linear-gradient(180deg, rgba(10,10,20,0.9), rgba(10,10,20,0.85));
            border-radius: 8px;
            transition: transform 0.15s ease, opacity 0.15s ease;
        }
        #side-panel.dock-right {
            right: 12px;
            top: 80px;
            width: 320px;
            max-height: calc(100vh - 160px);
            overflow: auto;
        }
        #side-panel.dock-bottom {
            left: 12px;
            right: 12px;
            bottom: 12px;
            height: 220px;
            max-height: 50vh;
            overflow: auto;
            border-radius: 8px;
        }
        #side-panel.hidden-panel { display: none; }
        /* Small dock buttons styling */
        .dock-btn { background: transparent; border: 1px solid rgba(255,255,255,0.06); color: #fff; padding: 6px 8px; border-radius: 6px; cursor: pointer; }
        .dock-btn.active { background: rgba(255,255,255,0.04); }
        /* Minimized draggable tile (snaps to sides) */
        #panel-min {
            position: fixed;
            width: 44px;
            height: 44px;
            border-radius: 8px;
            background: rgba(255,255,255,0.04);
            display: none;
            align-items: center;
            justify-content: center;
            color: #fff;
            cursor: grab;
            z-index: 3000;
            box-shadow: 0 6px 28px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.05);
            font-weight: 700;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <!-- Canvas with dual monitors (dynamic, populated by JS) -->
    <div id="canvas"></div>
    <!-- Side info panel -->
    <div id="side-panel" aria-hidden="false"></div>
    
    <!-- Timeline controls -->
    <div id="controls">
        <div id="timeline-container">
            <button id="playBtn" class="btn">? Play</button>
            <button id="resetBtn" class="btn">? Reset</button>
            <input type="range" id="timeline" min="0" max="1000" value="0">
            <span id="time-display">0.00s / 5.00s</span>
        </div>
        <div id="speed-control">
            <label>Speed:</label>
            <input type="range" id="speed" min="0.25" max="3" step="0.25" value="1">
            <span id="speed-display">1x</span>
        </div>
        <div id="info">
            <strong>Setup:</strong> Two stacked 1080p monitors (1920×1080 each). 
            Windows move between monitors over time.
            <br><br>
            <strong>Controls:</strong> Drag slider to scrub | Space = Play/Pause | ?/? = Step | Home = Reset
        </div>
    </div>

    <!--
        NOTE: For local file:// testing this page was used with the browser's
        strict file origin policy relaxed. In Firefox you can set
        `security.fileuri.strict_origin_policy` to `false` for testing only.
        Do NOT disable this setting in production — it weakens security.
    -->
    <script>
    // =============================
    // Timeline Animation Loader
    // =============================
    let timelineData = null;
    let timelineStart = 0;
    let timelineEnd = 0;
    let timelineDuration = 0;
    let timelinePlaybackSpeed = 1.0;
    let timelineLoop = true;
    let monitors = [];
    let windows = [];
    let monitorElements = {};
    let windowElements = {};
    let SCALE = 1, OFFSET_X = 0, OFFSET_Y = 0;
    let VIRTUAL_WIDTH = 1920, VIRTUAL_HEIGHT = 1080;
    let isPlaying = false, currentTime = 0, lastFrameTime = 0;
    let playBtn, resetBtn, timelineSlider, speedSlider, speedDisplay;
    let mousePath = [];
    let canvasEl = null;
    let isPanning = false;
    let panStartX = 0, panStartY = 0;
    let panOriginX = 0, panOriginY = 0;

    // Utility: Parse ISO timestamp to ms
    function parseTime(t) {
        return (typeof t === 'string') ? Date.parse(t) : t;
    }

    // Create side info panel (controls + info boxes)
    function setupInfoPanel() {
        let panel = document.getElementById('side-panel');
        if (!panel) return;
        panel.innerHTML = '';
        panel.classList.remove('dock-right','dock-bottom','hidden-panel');
        panel.classList.add('dock-right');
        // create minimized draggable tile to reopen when minimized
        let minTile = document.getElementById('panel-min');
        if (!minTile) {
            minTile = document.createElement('div');
            minTile.id = 'panel-min';
            minTile.textContent = '?';
            document.body.appendChild(minTile);
            // drag logic
            let dragging = false, dx=0, dy=0;
            minTile.addEventListener('mousedown', (ev)=>{
                dragging = true; dx = ev.clientX - minTile.offsetLeft; dy = ev.clientY - minTile.offsetTop; minTile.style.cursor = 'grabbing'; ev.preventDefault();
            });
            window.addEventListener('mousemove', (ev)=>{
                if (!dragging) return;
                let nx = ev.clientX - dx, ny = ev.clientY - dy;
                // constrain inside viewport
                nx = Math.max(8, Math.min(window.innerWidth - minTile.offsetWidth - 8, nx));
                ny = Math.max(8, Math.min(window.innerHeight - minTile.offsetHeight - 8, ny));
                minTile.style.left = nx + 'px'; minTile.style.top = ny + 'px';
            });
            window.addEventListener('mouseup', ()=>{
                if (!dragging) return; dragging = false; minTile.style.cursor = 'grab';
                // snap to nearest side (left or right or bottom)
                const midX = window.innerWidth / 2;
                const leftDist = parseFloat(minTile.style.left || 0);
                const top = parseFloat(minTile.style.top || 0);
                if (leftDist + minTile.offsetWidth/2 < midX) {
                    minTile.style.left = '8px';
                } else {
                    minTile.style.left = (window.innerWidth - minTile.offsetWidth - 8) + 'px';
                }
                // if near bottom, snap bottom
                if (top > window.innerHeight * 0.6) {
                    minTile.style.top = (window.innerHeight - minTile.offsetHeight - 8) + 'px';
                }
            });
            minTile.addEventListener('click', ()=>{ panel.classList.remove('hidden-panel'); minTile.style.display = 'none'; });
        }
        // Header with show/hide all
        const header = document.createElement('div');
        header.style.display = 'flex';
        header.style.gap = '8px';
        header.style.alignItems = 'center';
        const title = document.createElement('strong');
        title.textContent = 'Details';
        header.appendChild(title);
        const btnShowAll = document.createElement('button');
        btnShowAll.textContent = 'Show All';
        btnShowAll.className = 'btn';
        btnShowAll.style.padding = '6px 10px';
        btnShowAll.addEventListener('click', () => {
            panel.querySelectorAll('.panel-toggle').forEach(cb => { cb.checked = true; cb.dispatchEvent(new Event('change')); });
        });
        const btnHideAll = document.createElement('button');
        btnHideAll.textContent = 'Hide All';
        btnHideAll.className = 'btn';
        btnHideAll.style.padding = '6px 10px';
        btnHideAll.addEventListener('click', () => {
            panel.querySelectorAll('.panel-toggle').forEach(cb => { cb.checked = false; cb.dispatchEvent(new Event('change')); });
        });
        const ctrlWrap = document.createElement('div');
        ctrlWrap.style.marginLeft = 'auto';
        // Dock controls
        const btnDockRight = document.createElement('button'); btnDockRight.className='dock-btn'; btnDockRight.textContent='Dock Right';
        const btnDockBottom = document.createElement('button'); btnDockBottom.className='dock-btn'; btnDockBottom.textContent='Dock Bottom';
        const btnToggle = document.createElement('button'); btnToggle.className='dock-btn'; btnToggle.textContent='Minimize';
        btnDockRight.addEventListener('click', ()=>{ panel.classList.remove('dock-bottom'); panel.classList.add('dock-right'); btnDockRight.classList.add('active'); btnDockBottom.classList.remove('active'); });
        btnDockBottom.addEventListener('click', ()=>{ panel.classList.remove('dock-right'); panel.classList.add('dock-bottom'); btnDockBottom.classList.add('active'); btnDockRight.classList.remove('active'); });
        btnToggle.addEventListener('click', ()=>{
            // minimize to small draggable tile instead of hiding completely
            panel.classList.add('hidden-panel');
            const min = document.getElementById('panel-min');
            if (min) {
                // position based on current dock side
                const rect = panel.getBoundingClientRect();
                if (panel.classList.contains('dock-bottom')) {
                    // place centered along bottom dock
                    const left = Math.max(8, Math.min(window.innerWidth - min.offsetWidth - 8, rect.left + (rect.width - min.offsetWidth) / 2));
                    min.style.left = left + 'px';
                    min.style.top = (window.innerHeight - min.offsetHeight - 8) + 'px';
                } else {
                    // default to right dock placement
                    min.style.left = (window.innerWidth - min.offsetWidth - 8) + 'px';
                    // place near top of panel but ensure visible
                    const top = Math.max(8, Math.min(window.innerHeight - min.offsetHeight - 8, rect.top + 8));
                    min.style.top = top + 'px';
                }
                min.style.display = 'flex';
            }
        });
        // update minimized tile visibility helper
        const updateMinVisibility = () => {
            const min = document.getElementById('panel-min');
            if (!min) return;
            const hidden = panel.classList.contains('hidden-panel');
            min.style.display = hidden ? 'flex' : 'none';
        };
        // call on toggle click
        btnToggle.addEventListener('click', updateMinVisibility);
        // ensure initial state
        updateMinVisibility();
        btnDockRight.classList.add('active');
        ctrlWrap.appendChild(btnDockRight);
        ctrlWrap.appendChild(btnDockBottom);
        ctrlWrap.appendChild(btnToggle);
        ctrlWrap.appendChild(btnShowAll);
        ctrlWrap.appendChild(btnHideAll);
        header.appendChild(ctrlWrap);
        panel.appendChild(header);

        // Toggles and info for each window
        for (const w of windows) {
            const row = document.createElement('div');
            row.style.display = 'flex';
            row.style.alignItems = 'center';
            row.style.gap = '8px';
            row.style.marginTop = '8px';
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.checked = true;
            cb.className = 'panel-toggle';
            cb.dataset.target = 'info-' + w.id;
            const lbl = document.createElement('label');
            lbl.textContent = w.label || w.id;
            row.appendChild(cb);
            row.appendChild(lbl);
            panel.appendChild(row);

            const info = document.createElement('div');
            info.id = 'info-' + w.id;
            info.className = 'panel-item';
            info.style.marginTop = '6px';
            info.style.padding = '8px';
            info.style.background = 'rgba(255,255,255,0.03)';
            info.style.border = '1px solid rgba(255,255,255,0.03)';
            info.style.borderRadius = '6px';
            panel.appendChild(info);

            cb.addEventListener('change', (e) => {
                info.style.display = e.target.checked ? '' : 'none';
            });
        }

        // Mouse toggle + info
        const row = document.createElement('div');
        row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.gap = '8px'; row.style.marginTop = '8px';
        const cbMouse = document.createElement('input'); cbMouse.type = 'checkbox'; cbMouse.checked = true; cbMouse.className = 'panel-toggle'; cbMouse.dataset.target = 'info-mouse';
        const lblMouse = document.createElement('label'); lblMouse.textContent = 'Mouse';
        row.appendChild(cbMouse); row.appendChild(lblMouse); panel.appendChild(row);
        const infoMouse = document.createElement('div'); infoMouse.id = 'info-mouse'; infoMouse.className = 'panel-item'; infoMouse.style.marginTop='6px'; infoMouse.style.padding='8px'; infoMouse.style.background='rgba(255,255,255,0.03)'; infoMouse.style.border='1px solid rgba(255,255,255,0.03)'; infoMouse.style.borderRadius='6px'; panel.appendChild(infoMouse);
        cbMouse.addEventListener('change', (e)=>{ infoMouse.style.display = e.target.checked ? '' : 'none'; });
    }

    // Utility: Format ms as HH:mm:ss.SSS
    function formatTime(ms) {
        const d = new Date(ms);
        return d.toISOString().replace('T', ' ').replace('Z', '').slice(0, 23);
    }

    // Load JSON and initialize (with embedded fallback for file:// access)
    async function loadTimeline() {
        let data = null;
        try {
            const resp = await fetch('test.json');
            if (!resp.ok) throw new Error('Fetch failed');
            data = await resp.json();
        } catch (err) {
            console.warn('Failed to fetch test.json, using embedded fallback:', err);
            const EMBEDDED_JSON = `{
  "$schema": "./timeline-schema.json",
  "version": "1.1",
  "metadata": {
    "title": "Dual Monitor Window Movement Demo",
    "description": "Windows moving between two stacked 1080p monitors",
    "author": "FindNeedle",
    "created": "2024-01-15"
  },

  "timeline": {
    "start": "2024-01-15T10:30:00.000Z",
    "end": "2024-01-15T10:30:05.000Z",
    "playbackSpeed": 1.0,
    "loop": true
  },

  "monitors": [
    {
      "id": "monitor1",
      "label": "Monitor 1 (Top)",
      "keyframes": [
        { "time": "2024-01-15T10:30:00.000Z", "x": 0, "y": 0, "width": 1920, "height": 1080, "visible": true }
      ]
    },
    {
      "id": "monitor2", 
      "label": "Monitor 2 (Bottom)",
      "keyframes": [
        { "time": "2024-01-15T10:30:00.000Z", "x": 0, "y": 1080, "width": 1920, "height": 1080, "visible": true }
      ]
    }
  ],

  "windows": [
    {
      "id": "windowA",
      "label": "Window A",
      "style": {
        "gradient": ["#667eea", "#764ba2"],
        "borderRadius": 6
      },
      "keyframes": [
        { "time": "2024-01-15T10:30:00.000Z", "x": 100,  "y": 100,  "width": 300, "height": 200, "visible": true },
        { "time": "2024-01-15T10:30:01.500Z", "x": 800,  "y": 400,  "width": 350, "height": 220 },
        { "time": "2024-01-15T10:30:02.500Z", "x": 600,  "y": 1200, "width": 400, "height": 250 },
        { "time": "2024-01-15T10:30:04.000Z", "x": 1200, "y": 1400, "width": 320, "height": 200 },
        { "time": "2024-01-15T10:30:05.000Z", "x": 400,  "y": 300,  "width": 300, "height": 200 }
      ]
    },
    {
      "id": "windowB",
      "label": "Window B",
      "style": {
        "gradient": ["#f093fb", "#f5576c"],
        "borderRadius": 6
      },
      "keyframes": [
        { "time": "2024-01-15T10:30:00.000Z", "x": 1000, "y": 1300, "width": 280, "height": 180, "visible": true },
        { "time": "2024-01-15T10:30:01.250Z", "x": 1400, "y": 1600, "width": 300, "height": 200 },
        { "time": "2024-01-15T10:30:02.500Z", "x": 1200, "y": 600,  "width": 350, "height": 220 },
        { "time": "2024-01-15T10:30:03.750Z", "x": 200,  "y": 400,  "width": 320, "height": 200 },
        { "time": "2024-01-15T10:30:05.000Z", "x": 700,  "y": 1500, "width": 280, "height": 180 }
      ]
    },
    {
      "id": "windowC",
      "label": "Window C",
      "style": {
        "gradient": ["#4facfe", "#00f2fe"],
        "borderRadius": 6
      },
      "keyframes": [
        { "time": "2024-01-15T10:30:00.000Z", "x": 1400, "y": 200,  "width": 250, "height": 160, "visible": true },
        { "time": "2024-01-15T10:30:01.000Z", "x": 1500, "y": 900,  "width": 280, "height": 180 },
        { "time": "2024-01-15T10:30:02.000Z", "x": 800,  "y": 980,  "width": 400, "height": 200 },
        { "time": "2024-01-15T10:30:03.000Z", "x": 300,  "y": 1400, "width": 300, "height": 180 },
        { "time": "2024-01-15T10:30:04.000Z", "x": 100,  "y": 1800, "width": 260, "height": 170 },
        { "time": "2024-01-15T10:30:05.000Z", "x": 1300, "y": 500,  "width": 250, "height": 160 }
      ]
    }
  ]
}`;
            try {
                data = JSON.parse(EMBEDDED_JSON);
            } catch (parseErr) {
                console.error('Embedded JSON parse failed', parseErr);
                throw parseErr;
            }
        }

        timelineData = data;

        // Parse timeline
        const t = timelineData.timeline;
        timelineStart = parseTime(t.start);
        timelineEnd = parseTime(t.end);
        timelineDuration = timelineEnd - timelineStart;
        timelinePlaybackSpeed = t.playbackSpeed || 1.0;
        timelineLoop = t.loop !== false;

        // Parse monitors/windows
        monitors = timelineData.monitors.map(m => ({
            ...m,
            keyframes: m.keyframes.map(kf => ({ ...kf, time: parseTime(kf.time) }))
        }));
        windows = timelineData.windows.map(w => ({
            ...w,
            keyframes: w.keyframes.map(kf => ({ ...kf, time: parseTime(kf.time) }))
        }));

        // Mouse path: prefer JSON-provided path, otherwise use a default
        if (timelineData.mouse && Array.isArray(timelineData.mouse.keyframes)) {
            mousePath = timelineData.mouse.keyframes.map(kf => ({
                x: kf.x || 0,
                y: kf.y || 0,
                time: parseTime(kf.time)
            }));
        } else if (Array.isArray(timelineData.mousePath)) {
            mousePath = timelineData.mousePath.map(kf => ({
                x: kf.x || 0,
                y: kf.y || 0,
                time: parseTime(kf.time)
            }));
        } else {
            // Default mouse path (absolute times) if none provided
            mousePath = [
                { time: timelineStart, x: 200, y: 200 },
                { time: timelineStart + Math.floor(timelineDuration * 0.25), x: 600, y: 350 },
                { time: timelineStart + Math.floor(timelineDuration * 0.5), x: 900, y: 800 },
                { time: timelineStart + Math.floor(timelineDuration * 0.75), x: 700, y: 400 },
                { time: timelineEnd, x: 800, y: 300 }
            ];
        }

        // Compute virtual desktop size
        let minX = 0, minY = 0, maxX = 1920, maxY = 1080;
        for (const m of monitors) {
            for (const kf of m.keyframes) {
                minX = Math.min(minX, kf.x);
                minY = Math.min(minY, kf.y);
                maxX = Math.max(maxX, kf.x + kf.width);
                maxY = Math.max(maxY, kf.y + kf.height);
            }

        }
        VIRTUAL_WIDTH = maxX - minX;
        VIRTUAL_HEIGHT = maxY - minY;

        setupUI();
        setupMonitors();
        setupInfoPanel();
        currentTime = timelineStart;
        render(timelineStart);
    }

    // Setup UI and DOM
    function setupUI() {
        playBtn = document.getElementById('playBtn');
        resetBtn = document.getElementById('resetBtn');
        timelineSlider = document.getElementById('timeline');
        speedSlider = document.getElementById('speed');
        speedDisplay = document.getElementById('speed-display');

        // Set slider range to ms
        timelineSlider.min = timelineStart;
        timelineSlider.max = timelineEnd;
        timelineSlider.value = timelineStart;

        // Playback speed
        speedSlider.value = timelinePlaybackSpeed;
        speedDisplay.textContent = timelinePlaybackSpeed + 'x';

        // Handlers
        timelineSlider.addEventListener('input', (e) => {
            currentTime = parseInt(e.target.value);
            render(currentTime);
            if (isPlaying) {
                isPlaying = false;
                playBtn.textContent = '? Play';
                playBtn.classList.remove('active');
            }
        });
        speedSlider.addEventListener('input', (e) => {
            timelinePlaybackSpeed = parseFloat(e.target.value);
            speedDisplay.textContent = timelinePlaybackSpeed + 'x';
        });
        playBtn.addEventListener('click', () => {
            isPlaying = !isPlaying;
            playBtn.textContent = isPlaying ? '? Pause' : '? Play';
            playBtn.classList.toggle('active', isPlaying);
            if (isPlaying) {
                lastFrameTime = performance.now();
                requestAnimationFrame(animate);
            }
        });
        resetBtn.addEventListener('click', () => {
            currentTime = timelineStart;
            timelineSlider.value = timelineStart;
            render(currentTime);
            isPlaying = false;
            playBtn.textContent = '? Play';
            playBtn.classList.remove('active');
        });
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault(); playBtn.click();
            } else if (e.code === 'Home') {
                resetBtn.click();
            } else if (e.code === 'ArrowLeft') {
                currentTime = Math.max(timelineStart, currentTime - 50);
                timelineSlider.value = currentTime;
                render(currentTime);
            } else if (e.code === 'ArrowRight') {
                currentTime = Math.min(timelineEnd, currentTime + 50);
                timelineSlider.value = currentTime;
                render(currentTime);
            }
        });
    }

    // Setup monitors/windows DOM
    function setupMonitors() {
        const canvas = document.getElementById('canvas');
        canvasEl = canvas;
        canvas.innerHTML = '';
        monitorElements = {};
        windowElements = {};

        // Calculate scale
        const controlsHeight = document.getElementById('controls').offsetHeight;
        const availableWidth = window.innerWidth - 40;
        const availableHeight = window.innerHeight - controlsHeight - 80;
        const scaleX = availableWidth / VIRTUAL_WIDTH;
        const scaleY = availableHeight / VIRTUAL_HEIGHT;
        SCALE = Math.min(scaleX, scaleY, 0.5);
        OFFSET_X = 0; OFFSET_Y = 0;

        // Create monitor frames
        for (const m of monitors) {
            const frame = document.createElement('div');
            frame.className = 'monitor';
            frame.id = m.id + '-frame';
            const screen = document.createElement('div');
            screen.className = 'monitor-screen';
            screen.id = m.id;
            const label = document.createElement('span');
            label.className = 'monitor-label';
            label.textContent = m.label;
            const res = document.createElement('span');
            res.className = 'monitor-resolution';
            res.textContent = '';
            screen.appendChild(label);
            screen.appendChild(res);
            frame.appendChild(screen);
            canvas.appendChild(frame);
            monitorElements[m.id] = { frame, screen, label, res };
        }
        // Create window boxes
        for (const w of windows) {
            const box = document.createElement('div');
            box.className = 'box';
            box.id = w.id;
            box.textContent = w.label;
            canvas.appendChild(box);
            windowElements[w.id] = box;
        }

        // Create mouse cursor element
        let mouseEl = document.getElementById('mouse-cursor');
        if (!mouseEl) {
            mouseEl = document.createElement('div');
            mouseEl.id = 'mouse-cursor';
            mouseEl.className = 'mouse-cursor';
            canvas.appendChild(mouseEl);
        }

        // Mouse middle-button panning
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 1) { // middle button
                isPanning = true;
                panStartX = e.clientX; panStartY = e.clientY;
                panOriginX = OFFSET_X; panOriginY = OFFSET_Y;
                document.body.style.cursor = 'grabbing';
                e.preventDefault();
            }
        });
        window.addEventListener('mouseup', (e) => {
            if (e.button === 1 && isPanning) {
                isPanning = false;
                document.body.style.cursor = '';
            }
        });
        window.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            const dx = e.clientX - panStartX;
            const dy = e.clientY - panStartY;
            OFFSET_X = panOriginX + dx;
            OFFSET_Y = panOriginY + dy;
            render(currentTime);
        });
    }

    // Interpolate keyframes for a given time
    function interpolateKeyframes(keyframes, t) {
        if (!keyframes || keyframes.length === 0) return null;
        // If before first, clamp
        if (t <= keyframes[0].time) return { ...keyframes[0] };
        // If after last, clamp
        if (t >= keyframes[keyframes.length - 1].time) return { ...keyframes[keyframes.length - 1] };
        // Find prev/next
        let prev = keyframes[0], next = keyframes[keyframes.length - 1];
        for (let i = 0; i < keyframes.length - 1; i++) {
            if (t >= keyframes[i].time && t <= keyframes[i + 1].time) {
                prev = keyframes[i];
                next = keyframes[i + 1];
                break;
            }
        }
        const range = next.time - prev.time;
        const localT = range > 0 ? (t - prev.time) / range : 0;
        // Easing
        const easedT = localT < 0.5 ? 2 * localT * localT : 1 - Math.pow(-2 * localT + 2, 2) / 2;
        // Interpolate
        const interp = {};
        for (const k of ['x','y','width','height','opacity']) {
            if (prev[k] !== undefined && next[k] !== undefined)
                interp[k] = prev[k] + (next[k] - prev[k]) * easedT;
            else if (prev[k] !== undefined) interp[k] = prev[k];
        }
        // Visibility
        interp.visible = (prev.visible === false || next.visible === false) ? false : true;
        return interp;
    }

// Get mouse position at time t by interpolating mousePath
function getMouseAt(t) {
    if (!mousePath || mousePath.length === 0) return null;
    if (t <= mousePath[0].time) return { x: mousePath[0].x, y: mousePath[0].y };
    if (t >= mousePath[mousePath.length-1].time) return { x: mousePath[mousePath.length-1].x, y: mousePath[mousePath.length-1].y };
    let prev = mousePath[0], next = mousePath[mousePath.length-1];
    for (let i=0;i<mousePath.length-1;i++){
        if (t>=mousePath[i].time && t<=mousePath[i+1].time){ prev = mousePath[i]; next = mousePath[i+1]; break; }
    }
    const localT = (t - prev.time) / (next.time - prev.time);
    const eased = localT < 0.5 ? 2*localT*localT : 1 - Math.pow(-2*localT+2,2)/2;
    return { x: prev.x + (next.x - prev.x)*eased, y: prev.y + (next.y - prev.y)*eased };
}

    // Render everything for a given ms timestamp
    function render(t) {
        // Monitors
        for (const m of monitors) {
            const kf = interpolateKeyframes(m.keyframes, t);
            const el = monitorElements[m.id];
            if (!kf || !el) continue;
            // Position/size
            el.frame.style.display = kf.visible === false ? 'none' : '';
            el.frame.style.left = (kf.x * SCALE + OFFSET_X) + 'px';
            el.frame.style.top = (kf.y * SCALE + OFFSET_Y) + 'px';
            el.frame.style.width = (kf.width * SCALE) + 'px';
            el.frame.style.height = (kf.height * SCALE + 24) + 'px'; // +24 for stand
            el.screen.style.width = (kf.width * SCALE) + 'px';
            el.screen.style.height = (kf.height * SCALE) + 'px';
            el.res.textContent = `${Math.round(kf.width)}×${Math.round(kf.height)}`;
        }
        // Windows
        for (const w of windows) {
            const kf = interpolateKeyframes(w.keyframes, t);
            const el = windowElements[w.id];
            if (!kf || !el) continue;
            el.style.display = kf.visible === false ? 'none' : '';
            el.style.left = (kf.x * SCALE + OFFSET_X) + 'px';
            el.style.top = (kf.y * SCALE + OFFSET_Y) + 'px';
            el.style.width = (kf.width * SCALE) + 'px';
            el.style.height = (kf.height * SCALE) + 'px';
            // Style
            if (w.style && w.style.gradient) {
                el.style.background = `linear-gradient(135deg, ${w.style.gradient[0]} 0%, ${w.style.gradient[1]} 100%)`;
            } else if (w.style && w.style.color) {
                el.style.background = w.style.color;
            }
            el.style.borderRadius = (w.style && w.style.borderRadius ? w.style.borderRadius : 6) + 'px';
            el.style.opacity = kf.opacity !== undefined ? kf.opacity : (w.style && w.style.opacity !== undefined ? w.style.opacity : 1.0);
        }
        // Timeline slider and time display
        timelineSlider.value = t;
        const timeDisplay = document.getElementById('time-display');
        timeDisplay.textContent = `${formatTime(t)} / ${formatTime(timelineEnd)}`;

        // Mouse cursor
        const mouseEl = document.getElementById('mouse-cursor');
        if (mouseEl) {
            const pos = getMouseAt(t);
            if (pos) {
                mouseEl.style.left = (pos.x * SCALE + OFFSET_X) + 'px';
                mouseEl.style.top = (pos.y * SCALE + OFFSET_Y) + 'px';
                mouseEl.style.display = '';
            } else {
                mouseEl.style.display = 'none';
            }
        }

        // Update side panel info contents
        const panel = document.getElementById('side-panel');
        if (panel) {
            // ensure dock buttons reflect panel state
            const btns = panel.querySelectorAll('.dock-btn');
            // no-op here; buttons update state themselves
            for (const w of windows) {
                const info = document.getElementById('info-' + w.id);
                if (!info) continue;
                const v = interpolateKeyframes(w.keyframes, t);
                info.innerHTML = `<div><strong>${w.label || w.id}</strong></div>` +
                                 `<div>pos: ${Math.round(v.x)}, ${Math.round(v.y)}</div>` +
                                 `<div>size: ${Math.round(v.width)}×${Math.round(v.height)}</div>`;
            }
            const infoMouse = document.getElementById('info-mouse');
            if (infoMouse) {
                const mp = getMouseAt(t);
                if (mp) {
                    infoMouse.innerHTML = `<div><strong>Mouse</strong></div><div>pos: ${Math.round(mp.x)}, ${Math.round(mp.y)}</div>`;
                } else {
                    infoMouse.innerHTML = `<div><strong>Mouse</strong></div><div>pos: -</div>`;
                }
            }
        }
    }

    // Animation loop
    function animate(ts) {
        if (!isPlaying) return;
        const now = performance.now();
        const delta = now - lastFrameTime;
        lastFrameTime = now;
        let nextTime = currentTime + delta * timelinePlaybackSpeed;
        if (nextTime > timelineEnd) {
            if (timelineLoop) nextTime = timelineStart;
            else { isPlaying = false; playBtn.textContent = '? Play'; playBtn.classList.remove('active'); return; }
        }
        currentTime = nextTime;
        render(currentTime);
        requestAnimationFrame(animate);
    }

    // Responsive
    window.addEventListener('resize', () => {
        setupMonitors();
        render(currentTime);
    });

    // Zoom handling with wheel
    document.getElementById('canvas').addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = -e.deltaY || e.wheelDelta;
        const factor = delta > 0 ? 1.1 : 0.9;
        // Clamp SCALE
        SCALE = Math.max(0.1, Math.min(2, SCALE * factor));
        // Optionally adjust OFFSET to zoom to mouse position
        const rect = e.currentTarget.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        // adjust offsets so zoom centers on mouse
        OFFSET_X = OFFSET_X - (mx - OFFSET_X) * (factor - 1);
        OFFSET_Y = OFFSET_Y - (my - OFFSET_Y) * (factor - 1);
        render(currentTime);
    }, { passive: false });

    // Keyboard arrow panning
    document.addEventListener('keydown', (e) => {
        const panStep = 50; // pixels
        if (e.key === 'ArrowLeft') {
            OFFSET_X += panStep;
            render(currentTime);
        } else if (e.key === 'ArrowRight') {
            OFFSET_X -= panStep;
            render(currentTime);
        } else if (e.key === 'ArrowUp') {
            OFFSET_Y += panStep;
            render(currentTime);
        } else if (e.key === 'ArrowDown') {
            OFFSET_Y -= panStep;
            render(currentTime);
        }
    });

    // Start
    loadTimeline();
    </script>
</body>
</html>
