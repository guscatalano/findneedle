<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Timeline Demo - Dual Monitor Setup</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a2e;
            color: white;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
    

        /* Canvas area containing monitors */
        #canvas {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, #0d0d1a 0%, #1a1a2e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            gap: 8px;
        }
        
        /* Monitor frame styling */
        .monitor {
            position: absolute;
            background: #2a2a3e;
            border: 3px solid #444;
            border-radius: 8px;
            box-shadow: 
                0 0 0 2px #222,
                0 10px 30px rgba(0,0,0,0.5),
                inset 0 0 20px rgba(0,0,0,0.3);
        }
        
        .monitor::before {
            content: '';
            position: absolute;
            bottom: -20px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 15px;
            background: linear-gradient(to bottom, #333, #222);
            border-radius: 0 0 4px 4px;
        }
        
        .monitor-screen {
            position: relative;
            background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);
            overflow: hidden;
            border-radius: 4px;
            margin: 4px;
        }
        
        .monitor-label {
            position: absolute;
            top: 8px;
            left: 12px;
            font-size: 11px;
            opacity: 0.5;
            font-family: monospace;
            pointer-events: none;
            z-index: 10;
        }
        
        .monitor-resolution {
            position: absolute;
            top: 8px;
            right: 12px;
            font-size: 10px;
            opacity: 0.4;
            font-family: monospace;
            pointer-events: none;
            z-index: 10;
        }
        
        /* Boxes that move on screen */
        .box {
            position: absolute;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            transition: none;
            z-index: 20;
            pointer-events: none;
        }
        
        #box1 { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        #box2 { background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%); }
        #box3 { background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%); }
        
        /* Timeline controls */
        #controls {
            background: #0f0f23;
            padding: 20px;
            border-top: 1px solid #333;
        }
        
        #timeline-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }
        
        #timeline {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            background: #333;
            border-radius: 4px;
            cursor: pointer;
        }
        
        #timeline::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: #667eea;
            border-radius: 50%;
            cursor: grab;
        }
        
        #timeline::-webkit-slider-thumb:active {
            cursor: grabbing;
        }
        
        #time-display {
            font-family: monospace;
            font-size: 16px;
            min-width: 100px;
        }
        
        .btn {
            background: #667eea;
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            margin-right: 10px;
        }
        
        .btn:hover { background: #5a6fd6; }
        .btn.active { background: #f5576c; }
        
        #info {
            font-size: 12px;
            opacity: 0.7;
            margin-top: 10px;
        }
        
        #speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        
        #speed-control label {
            font-size: 12px;
            opacity: 0.7;
        }
        
        #speed {
            width: 100px;
        }
        
        /* Mouse cursor */
        .mouse-cursor {
            position: absolute;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: rgba(255,255,255,0.95);
            box-shadow: 0 2px 6px rgba(0,0,0,0.5);
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <!-- Canvas with dual monitors (dynamic, populated by JS) -->
    <div id="canvas"></div>
    
    <!-- Timeline controls -->
    <div id="controls">
        <div id="timeline-container">
            <button id="playBtn" class="btn">? Play</button>
            <button id="resetBtn" class="btn">? Reset</button>
            <input type="range" id="timeline" min="0" max="1000" value="0">
            <span id="time-display">0.00s / 5.00s</span>
        </div>
        <div id="speed-control">
            <label>Speed:</label>
            <input type="range" id="speed" min="0.25" max="3" step="0.25" value="1">
            <span id="speed-display">1x</span>
        </div>
        <div id="info">
            <strong>Setup:</strong> Two stacked 1080p monitors (1920×1080 each). 
            Windows move between monitors over time.
            <br><br>
            <strong>Controls:</strong> Drag slider to scrub | Space = Play/Pause | ?/? = Step | Home = Reset
        </div>
    </div>

    <script>
    // =============================
    // Timeline Animation Loader
    // =============================
    let timelineData = null;
    let timelineStart = 0;
    let timelineEnd = 0;
    let timelineDuration = 0;
    let timelinePlaybackSpeed = 1.0;
    let timelineLoop = true;
    let monitors = [];
    let windows = [];
    let monitorElements = {};
    let windowElements = {};
    let SCALE = 1, OFFSET_X = 0, OFFSET_Y = 0;
    let VIRTUAL_WIDTH = 1920, VIRTUAL_HEIGHT = 1080;
    let isPlaying = false, currentTime = 0, lastFrameTime = 0;
    let playBtn, resetBtn, timelineSlider, speedSlider, speedDisplay;
    let mousePath = [];
    let canvasEl = null;
    let isPanning = false;
    let panStartX = 0, panStartY = 0;
    let panOriginX = 0, panOriginY = 0;

    // Utility: Parse ISO timestamp to ms
    function parseTime(t) {
        return (typeof t === 'string') ? Date.parse(t) : t;
    }

    // Utility: Format ms as HH:mm:ss.SSS
    function formatTime(ms) {
        const d = new Date(ms);
        return d.toISOString().replace('T', ' ').replace('Z', '').slice(0, 23);
    }

    // Load JSON and initialize (with embedded fallback for file:// access)
    async function loadTimeline() {
        let data = null;
        try {
            const resp = await fetch('test.json');
            if (!resp.ok) throw new Error('Fetch failed');
            data = await resp.json();
        } catch (err) {
            console.warn('Failed to fetch test.json, using embedded fallback:', err);
            const EMBEDDED_JSON = `{
  "$schema": "./timeline-schema.json",
  "version": "1.1",
  "metadata": {
    "title": "Dual Monitor Window Movement Demo",
    "description": "Windows moving between two stacked 1080p monitors",
    "author": "FindNeedle",
    "created": "2024-01-15"
  },

  "timeline": {
    "start": "2024-01-15T10:30:00.000Z",
    "end": "2024-01-15T10:30:05.000Z",
    "playbackSpeed": 1.0,
    "loop": true
  },

  "monitors": [
    {
      "id": "monitor1",
      "label": "Monitor 1 (Top)",
      "keyframes": [
        { "time": "2024-01-15T10:30:00.000Z", "x": 0, "y": 0, "width": 1920, "height": 1080, "visible": true }
      ]
    },
    {
      "id": "monitor2", 
      "label": "Monitor 2 (Bottom)",
      "keyframes": [
        { "time": "2024-01-15T10:30:00.000Z", "x": 0, "y": 1080, "width": 1920, "height": 1080, "visible": true }
      ]
    }
  ],

  "windows": [
    {
      "id": "windowA",
      "label": "Window A",
      "style": {
        "gradient": ["#667eea", "#764ba2"],
        "borderRadius": 6
      },
      "keyframes": [
        { "time": "2024-01-15T10:30:00.000Z", "x": 100,  "y": 100,  "width": 300, "height": 200, "visible": true },
        { "time": "2024-01-15T10:30:01.500Z", "x": 800,  "y": 400,  "width": 350, "height": 220 },
        { "time": "2024-01-15T10:30:02.500Z", "x": 600,  "y": 1200, "width": 400, "height": 250 },
        { "time": "2024-01-15T10:30:04.000Z", "x": 1200, "y": 1400, "width": 320, "height": 200 },
        { "time": "2024-01-15T10:30:05.000Z", "x": 400,  "y": 300,  "width": 300, "height": 200 }
      ]
    },
    {
      "id": "windowB",
      "label": "Window B",
      "style": {
        "gradient": ["#f093fb", "#f5576c"],
        "borderRadius": 6
      },
      "keyframes": [
        { "time": "2024-01-15T10:30:00.000Z", "x": 1000, "y": 1300, "width": 280, "height": 180, "visible": true },
        { "time": "2024-01-15T10:30:01.250Z", "x": 1400, "y": 1600, "width": 300, "height": 200 },
        { "time": "2024-01-15T10:30:02.500Z", "x": 1200, "y": 600,  "width": 350, "height": 220 },
        { "time": "2024-01-15T10:30:03.750Z", "x": 200,  "y": 400,  "width": 320, "height": 200 },
        { "time": "2024-01-15T10:30:05.000Z", "x": 700,  "y": 1500, "width": 280, "height": 180 }
      ]
    },
    {
      "id": "windowC",
      "label": "Window C",
      "style": {
        "gradient": ["#4facfe", "#00f2fe"],
        "borderRadius": 6
      },
      "keyframes": [
        { "time": "2024-01-15T10:30:00.000Z", "x": 1400, "y": 200,  "width": 250, "height": 160, "visible": true },
        { "time": "2024-01-15T10:30:01.000Z", "x": 1500, "y": 900,  "width": 280, "height": 180 },
        { "time": "2024-01-15T10:30:02.000Z", "x": 800,  "y": 980,  "width": 400, "height": 200 },
        { "time": "2024-01-15T10:30:03.000Z", "x": 300,  "y": 1400, "width": 300, "height": 180 },
        { "time": "2024-01-15T10:30:04.000Z", "x": 100,  "y": 1800, "width": 260, "height": 170 },
        { "time": "2024-01-15T10:30:05.000Z", "x": 1300, "y": 500,  "width": 250, "height": 160 }
      ]
    }
  ]
}`;
            try {
                data = JSON.parse(EMBEDDED_JSON);
            } catch (parseErr) {
                console.error('Embedded JSON parse failed', parseErr);
                throw parseErr;
            }
        }

        timelineData = data;

        // Parse timeline
        const t = timelineData.timeline;
        timelineStart = parseTime(t.start);
        timelineEnd = parseTime(t.end);
        timelineDuration = timelineEnd - timelineStart;
        timelinePlaybackSpeed = t.playbackSpeed || 1.0;
        timelineLoop = t.loop !== false;

        // Parse monitors/windows
        monitors = timelineData.monitors.map(m => ({
            ...m,
            keyframes: m.keyframes.map(kf => ({ ...kf, time: parseTime(kf.time) }))
        }));
        windows = timelineData.windows.map(w => ({
            ...w,
            keyframes: w.keyframes.map(kf => ({ ...kf, time: parseTime(kf.time) }))
        }));

        // Default mouse path (absolute times) if none provided
        mousePath = [
            { time: timelineStart, x: 200, y: 200 },
            { time: timelineStart + Math.floor(timelineDuration * 0.25), x: 600, y: 350 },
            { time: timelineStart + Math.floor(timelineDuration * 0.5), x: 900, y: 800 },
            { time: timelineStart + Math.floor(timelineDuration * 0.75), x: 700, y: 400 },
            { time: timelineEnd, x: 800, y: 300 }
        ];

        // Compute virtual desktop size
        let minX = 0, minY = 0, maxX = 1920, maxY = 1080;
        for (const m of monitors) {
            for (const kf of m.keyframes) {
                minX = Math.min(minX, kf.x);
                minY = Math.min(minY, kf.y);
                maxX = Math.max(maxX, kf.x + kf.width);
                maxY = Math.max(maxY, kf.y + kf.height);
            }

        }
        VIRTUAL_WIDTH = maxX - minX;
        VIRTUAL_HEIGHT = maxY - minY;

        setupUI();
        setupMonitors();
        currentTime = timelineStart;
        render(timelineStart);
    }

    // Setup UI and DOM
    function setupUI() {
        playBtn = document.getElementById('playBtn');
        resetBtn = document.getElementById('resetBtn');
        timelineSlider = document.getElementById('timeline');
        speedSlider = document.getElementById('speed');
        speedDisplay = document.getElementById('speed-display');

        // Set slider range to ms
        timelineSlider.min = timelineStart;
        timelineSlider.max = timelineEnd;
        timelineSlider.value = timelineStart;

        // Playback speed
        speedSlider.value = timelinePlaybackSpeed;
        speedDisplay.textContent = timelinePlaybackSpeed + 'x';

        // Handlers
        timelineSlider.addEventListener('input', (e) => {
            currentTime = parseInt(e.target.value);
            render(currentTime);
            if (isPlaying) {
                isPlaying = false;
                playBtn.textContent = '? Play';
                playBtn.classList.remove('active');
            }
        });
        speedSlider.addEventListener('input', (e) => {
            timelinePlaybackSpeed = parseFloat(e.target.value);
            speedDisplay.textContent = timelinePlaybackSpeed + 'x';
        });
        playBtn.addEventListener('click', () => {
            isPlaying = !isPlaying;
            playBtn.textContent = isPlaying ? '? Pause' : '? Play';
            playBtn.classList.toggle('active', isPlaying);
            if (isPlaying) {
                lastFrameTime = performance.now();
                requestAnimationFrame(animate);
            }
        });
        resetBtn.addEventListener('click', () => {
            currentTime = timelineStart;
            timelineSlider.value = timelineStart;
            render(currentTime);
            isPlaying = false;
            playBtn.textContent = '? Play';
            playBtn.classList.remove('active');
        });
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault(); playBtn.click();
            } else if (e.code === 'Home') {
                resetBtn.click();
            } else if (e.code === 'ArrowLeft') {
                currentTime = Math.max(timelineStart, currentTime - 50);
                timelineSlider.value = currentTime;
                render(currentTime);
            } else if (e.code === 'ArrowRight') {
                currentTime = Math.min(timelineEnd, currentTime + 50);
                timelineSlider.value = currentTime;
                render(currentTime);
            }
        });
    }

    // Setup monitors/windows DOM
    function setupMonitors() {
        const canvas = document.getElementById('canvas');
        canvasEl = canvas;
        canvas.innerHTML = '';
        monitorElements = {};
        windowElements = {};

        // Calculate scale
        const controlsHeight = document.getElementById('controls').offsetHeight;
        const availableWidth = window.innerWidth - 40;
        const availableHeight = window.innerHeight - controlsHeight - 80;
        const scaleX = availableWidth / VIRTUAL_WIDTH;
        const scaleY = availableHeight / VIRTUAL_HEIGHT;
        SCALE = Math.min(scaleX, scaleY, 0.5);
        OFFSET_X = 0; OFFSET_Y = 0;

        // Create monitor frames
        for (const m of monitors) {
            const frame = document.createElement('div');
            frame.className = 'monitor';
            frame.id = m.id + '-frame';
            const screen = document.createElement('div');
            screen.className = 'monitor-screen';
            screen.id = m.id;
            const label = document.createElement('span');
            label.className = 'monitor-label';
            label.textContent = m.label;
            const res = document.createElement('span');
            res.className = 'monitor-resolution';
            res.textContent = '';
            screen.appendChild(label);
            screen.appendChild(res);
            frame.appendChild(screen);
            canvas.appendChild(frame);
            monitorElements[m.id] = { frame, screen, label, res };
        }
        // Create window boxes
        for (const w of windows) {
            const box = document.createElement('div');
            box.className = 'box';
            box.id = w.id;
            box.textContent = w.label;
            canvas.appendChild(box);
            windowElements[w.id] = box;
        }

        // Create mouse cursor element
        let mouseEl = document.getElementById('mouse-cursor');
        if (!mouseEl) {
            mouseEl = document.createElement('div');
            mouseEl.id = 'mouse-cursor';
            mouseEl.className = 'mouse-cursor';
            canvas.appendChild(mouseEl);
        }

        // Mouse middle-button panning
        canvas.addEventListener('mousedown', (e) => {
            if (e.button === 1) { // middle button
                isPanning = true;
                panStartX = e.clientX; panStartY = e.clientY;
                panOriginX = OFFSET_X; panOriginY = OFFSET_Y;
                document.body.style.cursor = 'grabbing';
                e.preventDefault();
            }
        });
        window.addEventListener('mouseup', (e) => {
            if (e.button === 1 && isPanning) {
                isPanning = false;
                document.body.style.cursor = '';
            }
        });
        window.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            const dx = e.clientX - panStartX;
            const dy = e.clientY - panStartY;
            OFFSET_X = panOriginX + dx;
            OFFSET_Y = panOriginY + dy;
            render(currentTime);
        });
    }

    // Interpolate keyframes for a given time
    function interpolateKeyframes(keyframes, t) {
        if (!keyframes || keyframes.length === 0) return null;
        // If before first, clamp
        if (t <= keyframes[0].time) return { ...keyframes[0] };
        // If after last, clamp
        if (t >= keyframes[keyframes.length - 1].time) return { ...keyframes[keyframes.length - 1] };
        // Find prev/next
        let prev = keyframes[0], next = keyframes[keyframes.length - 1];
        for (let i = 0; i < keyframes.length - 1; i++) {
            if (t >= keyframes[i].time && t <= keyframes[i + 1].time) {
                prev = keyframes[i];
                next = keyframes[i + 1];
                break;
            }
        }
        const range = next.time - prev.time;
        const localT = range > 0 ? (t - prev.time) / range : 0;
        // Easing
        const easedT = localT < 0.5 ? 2 * localT * localT : 1 - Math.pow(-2 * localT + 2, 2) / 2;
        // Interpolate
        const interp = {};
        for (const k of ['x','y','width','height','opacity']) {
            if (prev[k] !== undefined && next[k] !== undefined)
                interp[k] = prev[k] + (next[k] - prev[k]) * easedT;
            else if (prev[k] !== undefined) interp[k] = prev[k];
        }
        // Visibility
        interp.visible = (prev.visible === false || next.visible === false) ? false : true;
        return interp;
    }

// Get mouse position at time t by interpolating mousePath
function getMouseAt(t) {
    if (!mousePath || mousePath.length === 0) return null;
    if (t <= mousePath[0].time) return { x: mousePath[0].x, y: mousePath[0].y };
    if (t >= mousePath[mousePath.length-1].time) return { x: mousePath[mousePath.length-1].x, y: mousePath[mousePath.length-1].y };
    let prev = mousePath[0], next = mousePath[mousePath.length-1];
    for (let i=0;i<mousePath.length-1;i++){
        if (t>=mousePath[i].time && t<=mousePath[i+1].time){ prev = mousePath[i]; next = mousePath[i+1]; break; }
    }
    const localT = (t - prev.time) / (next.time - prev.time);
    const eased = localT < 0.5 ? 2*localT*localT : 1 - Math.pow(-2*localT+2,2)/2;
    return { x: prev.x + (next.x - prev.x)*eased, y: prev.y + (next.y - prev.y)*eased };
}

    // Render everything for a given ms timestamp
    function render(t) {
        // Monitors
        for (const m of monitors) {
            const kf = interpolateKeyframes(m.keyframes, t);
            const el = monitorElements[m.id];
            if (!kf || !el) continue;
            // Position/size
            el.frame.style.display = kf.visible === false ? 'none' : '';
            el.frame.style.left = (kf.x * SCALE + OFFSET_X) + 'px';
            el.frame.style.top = (kf.y * SCALE + OFFSET_Y) + 'px';
            el.frame.style.width = (kf.width * SCALE) + 'px';
            el.frame.style.height = (kf.height * SCALE + 24) + 'px'; // +24 for stand
            el.screen.style.width = (kf.width * SCALE) + 'px';
            el.screen.style.height = (kf.height * SCALE) + 'px';
            el.res.textContent = `${Math.round(kf.width)}×${Math.round(kf.height)}`;
        }
        // Windows
        for (const w of windows) {
            const kf = interpolateKeyframes(w.keyframes, t);
            const el = windowElements[w.id];
            if (!kf || !el) continue;
            el.style.display = kf.visible === false ? 'none' : '';
            el.style.left = (kf.x * SCALE + OFFSET_X) + 'px';
            el.style.top = (kf.y * SCALE + OFFSET_Y) + 'px';
            el.style.width = (kf.width * SCALE) + 'px';
            el.style.height = (kf.height * SCALE) + 'px';
            // Style
            if (w.style && w.style.gradient) {
                el.style.background = `linear-gradient(135deg, ${w.style.gradient[0]} 0%, ${w.style.gradient[1]} 100%)`;
            } else if (w.style && w.style.color) {
                el.style.background = w.style.color;
            }
            el.style.borderRadius = (w.style && w.style.borderRadius ? w.style.borderRadius : 6) + 'px';
            el.style.opacity = kf.opacity !== undefined ? kf.opacity : (w.style && w.style.opacity !== undefined ? w.style.opacity : 1.0);
        }
        // Timeline slider and time display
        timelineSlider.value = t;
        const timeDisplay = document.getElementById('time-display');
        timeDisplay.textContent = `${formatTime(t)} / ${formatTime(timelineEnd)}`;

        // Mouse cursor
        const mouseEl = document.getElementById('mouse-cursor');
        if (mouseEl) {
            const pos = getMouseAt(t);
            if (pos) {
                mouseEl.style.left = (pos.x * SCALE + OFFSET_X) + 'px';
                mouseEl.style.top = (pos.y * SCALE + OFFSET_Y) + 'px';
                mouseEl.style.display = '';
            } else {
                mouseEl.style.display = 'none';
            }
        }
    }

    // Animation loop
    function animate(ts) {
        if (!isPlaying) return;
        const now = performance.now();
        const delta = now - lastFrameTime;
        lastFrameTime = now;
        let nextTime = currentTime + delta * timelinePlaybackSpeed;
        if (nextTime > timelineEnd) {
            if (timelineLoop) nextTime = timelineStart;
            else { isPlaying = false; playBtn.textContent = '? Play'; playBtn.classList.remove('active'); return; }
        }
        currentTime = nextTime;
        render(currentTime);
        requestAnimationFrame(animate);
    }

    // Responsive
    window.addEventListener('resize', () => {
        setupMonitors();
        render(currentTime);
    });

    // Zoom handling with wheel
    document.getElementById('canvas').addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = -e.deltaY || e.wheelDelta;
        const factor = delta > 0 ? 1.1 : 0.9;
        // Clamp SCALE
        SCALE = Math.max(0.1, Math.min(2, SCALE * factor));
        // Optionally adjust OFFSET to zoom to mouse position
        const rect = e.currentTarget.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        // adjust offsets so zoom centers on mouse
        OFFSET_X = OFFSET_X - (mx - OFFSET_X) * (factor - 1);
        OFFSET_Y = OFFSET_Y - (my - OFFSET_Y) * (factor - 1);
        render(currentTime);
    }, { passive: false });

    // Keyboard arrow panning
    document.addEventListener('keydown', (e) => {
        const panStep = 50; // pixels
        if (e.key === 'ArrowLeft') {
            OFFSET_X += panStep;
            render(currentTime);
        } else if (e.key === 'ArrowRight') {
            OFFSET_X -= panStep;
            render(currentTime);
        } else if (e.key === 'ArrowUp') {
            OFFSET_Y += panStep;
            render(currentTime);
        } else if (e.key === 'ArrowDown') {
            OFFSET_Y -= panStep;
            render(currentTime);
        }
    });

    // Start
    loadTimeline();
    </script>
</body>
</html>
