# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# This workflow will build, test, sign and package a WPF or Windows Forms desktop application
# built on .NET Core.
# To learn how to migrate your existing application to .NET Core,
# refer to https://docs.microsoft.com/en-us/dotnet/desktop-wpf/migration/convert-project-from-net-framework
#
# To configure this workflow:
#
# 1. Configure environment variables
# GitHub sets default environment variables for every workflow run.
# Replace the variables relative to your project in the "env" section below.
#
# 2. Signing
# Generate a signing certificate in the Windows Application
# Packaging Project or add an existing signing certificate to the project.
# Next, use PowerShell to encode the .pfx file using Base64 encoding
# by running the following Powershell script to generate the output string:
#
# $pfx_cert = Get-Content '.\SigningCertificate.pfx' -Encoding Byte
# [System.Convert]::ToBase64String($pfx_cert) | Out-File 'SigningCertificate_Encoded.txt'
#
# Open the output file, SigningCertificate_Encoded.txt, and copy the
# string inside. Then, add the string to the repo as a GitHub secret
# and name it "Base64_Encoded_Pfx."
# For more information on how to configure your signing certificate for
# this workflow, refer to https://github.com/microsoft/github-actions-for-desktop-apps#signing
#
# Finally, add the signing certificate password to the repo as a secret and name it "Pfx_Key".
# See "Build the Windows Application Packaging project" below to see how the secret is used.
#
# For more information on GitHub Actions, refer to https://github.com/features/actions
# For a complete CI/CD sample to get started with GitHub Action workflows for Desktop Applications,
# refer to https://github.com/microsoft/github-actions-for-desktop-apps

name: .NET Core Desktop

permissions:
  contents: write
  checks: write

on:
  push:
    branches: [ "master" ]
    tags:
      - 'v*.*.*'

  pull_request:
    branches: [ "master" ]

env:
  Solution_Name: findneedle.sln
  FindNeedleUX_Project: FindNeedleUX/FindNeedleUX.csproj
  GH_TOKEN: ${{ github.token }}
  MAX_TAGS: 5

jobs:

  create-release:
    needs: [build-release, test-publish]
    if: needs.test-publish.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      releasetag: ${{ steps.currenttag.outputs.tag }}

    steps:
    - name: Check Test Results
      run: |
        echo "Test results must be checked in the test job."

    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # Get changed files for this commit (must be before any step that uses its output)
    - name: Get changed files
      id: get_changed_files
      uses: tj-actions/changed-files@v46
      with:
        separator: ','

    # Remove older tags and releases if more than 50 exist (skip if workflow changed)
    - name: Remove older tags and releases if more than 50 exist (skip if workflow changed)
      if: github.ref == 'refs/heads/master' && !contains(join(steps.get_changed_files.outputs.all_changed_files, ','), '.github/workflows/dotnet-desktop.yml')
      id: remove_old_tags
      run: |
        $ErrorActionPreference = 'Stop'
        # Install GitHub CLI if not present
        if (-not (Get-Command gh -ErrorAction SilentlyContinue)) {
          Invoke-WebRequest -Uri "https://github.com/cli/cli/releases/download/v2.49.0/gh_2.49.0_windows_amd64.zip" -OutFile "ghcli.zip"
          Expand-Archive ghcli.zip -DestinationPath ghcli
          $env:Path += ";$pwd\ghcli\gh_2.49.0_windows_amd64\bin"
        }
        $maxTags = $env:MAX_TAGS
        $tags = git tag --sort=-creatordate
        $tagCount = ($tags | Measure-Object -Line).Lines
        if ($tagCount -gt $maxTags) {
          $tagsToDelete = $tags | Select-Object -Skip $maxTags
          foreach ($tag in $tagsToDelete) {
            Write-Host "Deleting old tag: $tag"
            git tag -d $tag
            git push --delete origin $tag
            try {
              gh release delete $tag --yes
              Write-Host "Deleted release for tag: $tag"
            } catch {
              Write-Host "No release found for tag: $tag or failed to delete."
            }
          }
        } else {
          Write-Host "Tag count ($tagCount) is $maxTags or less. No tags or releases deleted."
        }
      shell: pwsh

    # Only create a release/tag if workflow file was not changed
    - name: Create an incremental release (skip if workflow changed)
      if: github.ref == 'refs/heads/master' && !contains(join(steps.get_changed_files.outputs.all_changed_files, ','), '.github/workflows/dotnet-desktop.yml')
      uses: aurestic/incrementarl-create-release@master
      with:
        flag_branch: true
        message: Bump version
        prev_tag: 'v'
        update_odoo_module_version: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    # Get Previous tag
    - name: 'Get Previous tag'
      id: currenttag
      uses: "WyriHaximus/github-action-get-previous-tag@v1"
      with:
        fallback: 1.0.0 # Optional fallback tag to use when no tag can be found
        #workingDirectory: another/path/where/a/git/repo/is/checked/out # Optional alternative working directory

  discover-test-projects:
    runs-on: ubuntu-latest
    outputs:
      test_projects: ${{ steps.find-tests.outputs.test_projects }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Find all test projects
        id: find-tests
        run: |
          # Find all .csproj files that look like test projects (by convention, in folders ending with 'Tests')
          TEST_PROJECTS=$(find . -type f -name "*.csproj" | grep -i 'Tests/' | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "Found test projects: $TEST_PROJECTS"
          echo "::notice::Discovered test projects: $TEST_PROJECTS"
          if [ "$TEST_PROJECTS" = "[]" ]; then
            echo "::error::No test projects discovered. Failing the job."
            exit 1
          fi
          echo "test_projects=$TEST_PROJECTS" >> $GITHUB_OUTPUT
      - name: Write discovered test projects to file
        run: |
          echo '${{ steps.find-tests.outputs.test_projects }}' > test-projects.json
      - name: Upload discovered test project list
        uses: actions/upload-artifact@v4
        with:
          name: test-projects-list
          path: test-projects.json

  build-debug:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Cache NuGet packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: ${{ runner.os }}-nuget-
      - name: Restore dependencies
        run: dotnet restore ${{ env.Solution_Name }}
      - name: Build solution (Debug)
        run: dotnet build ${{ env.Solution_Name }} --configuration Debug --no-restore
      - name: Publish all projects (Debug, x64)
        run: |
          for %%f in (*.csproj) do (
            for /f "usebackq tokens=*" %%t in (`powershell -Command "try { (Select-String -Path '%%f' -Pattern '<TargetFramework>(.+)</TargetFramework>' | Select-Object -First 1).Matches[0].Groups[1].Value } catch { '' }"`) do (
              if not "%%t"=="" dotnet publish "%%f" --configuration Debug --framework %%t --output "%%~dpfbin\x64\Debug\publish" --runtime win-x64 /p:Platform=x64
            )
          )
          for %%f in (*\*.csproj) do (
            for /f "usebackq tokens=*" %%t in (`powershell -Command "try { (Select-String -Path '%%f' -Pattern '<TargetFramework>(.+)</TargetFramework>' | Select-Object -First 1).Matches[0].Groups[1].Value } catch { '' }"`) do (
              if not "%%t"=="" dotnet publish "%%f" --configuration Debug --framework %%t --output "%%~dpfbin\x64\Debug\publish" --runtime win-x64 /p:Platform=x64
            )
          )
          for %%f in (*\*\*.csproj) do (
            for /f "usebackq tokens=*" %%t in (`powershell -Command "try { (Select-String -Path '%%f' -Pattern '<TargetFramework>(.+)</TargetFramework>' | Select-Object -First 1).Matches[0].Groups[1].Value } catch { '' }"`) do (
              if not "%%t"=="" dotnet publish "%%f" --configuration Debug --framework %%t --output "%%~dpfbin\x64\Debug\publish" --runtime win-x64 /p:Platform=x64
            )
          )
        shell: cmd
      - name: Download discovered test project list
        uses: actions/download-artifact@v4
        with:
          name: test-projects-list
          path: .
      - name: Build all discovered test projects (Debug, x64, net8.0-windows10.0.19041.0)
        shell: pwsh
        run: |
          $testProjects = Get-Content test-projects.json | ConvertFrom-Json
          foreach ($proj in $testProjects) {
            Write-Host "Building test project: $proj"
            dotnet build $proj --configuration Debug --framework net8.0-windows10.0.19041.0
          }
      - name: Diagnostic - List all discovered test project bin folders after build
        shell: pwsh
        run: |
          $testProjects = Get-Content test-projects.json | ConvertFrom-Json
          foreach ($proj in $testProjects) {
            $bindir = Join-Path (Split-Path $proj -Parent) 'bin'
            Write-Host "Project: $proj"
            Get-ChildItem -Path $bindir -Recurse -ErrorAction SilentlyContinue | Write-Host
          }
      - name: Diagnostic - List all test project csproj files
        run: |
          echo Listing all test project csproj files:
          dir /b /s *.csproj | findstr /i Tests
        shell: cmd
      - name: Diagnostic - Build each test project and echo output
        run: |
          for %%f in (*Tests\*.csproj) do (
            echo Building %%f ...
            dotnet build "%%f" --configuration Debug --framework net8.0-windows10.0.19041.0 --runtime win-x64 --output "%%~dpfbin\x64\Debug\net8.0-windows10.0.19041.0\win-x64" /p:Platform=x64
            echo Result for %%f: %ERRORLEVEL%
          )
        shell: cmd
      - name: Diagnostic - List all publish folders and contents before upload
        shell: pwsh
        run: |
          Write-Host "Listing all publish folders and their contents before artifact upload:"
          Get-ChildItem -Path . -Recurse -Directory -Filter publish | ForEach-Object {
            Write-Host "Found publish folder: $($_.FullName)"
            Get-ChildItem -Path $_.FullName -Recurse | ForEach-Object { Write-Host $_.FullName }
          }
      - name: Upload all build outputs (Debug)
        uses: actions/upload-artifact@v4
        with:
          name: build-output-Debug
          path: .
          retention-days: 2
          

  build-release:
    runs-on: windows-latest
    strategy:
      matrix:
        platform: [x64]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Cache NuGet packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: ${{ runner.os }}-nuget-
      - name: Restore dependencies
        run: dotnet restore ${{ env.Solution_Name }}
      - name: Build solution (Release, ${{ matrix.platform }})
        run: dotnet build ${{ env.Solution_Name }} --configuration Release --no-restore /p:Platform=${{ matrix.platform }}
      - name: Publish FindNeedleUX (Release only, x64)
        if: matrix.platform == 'x64'
        run: dotnet publish ${{ env.FindNeedleUX_Project }} --configuration Release --output ${{ github.workspace }}/publish /p:Platform=x64
      - name: Archive Release (Release only, x64)
        if: matrix.platform == 'x64'
        uses: thedoctor0/zip-release@0.7.5
        with:
          type: 'zip'
          directory: '${{ github.workspace }}/publish'
          filename: 'release.zip'
          exclusions: '*.git* /*node_modules/*.editorconfig'
      - name: Upload Release bits (Release only, x64)
        if: matrix.platform == 'x64'
        uses: actions/upload-artifact@v4
        with:
          name: release-bits
          path: ${{ github.workspace }}/publish/release.zip
          retention-days: 5

  make_msix_signed:
    needs: [build-release]
    strategy:
      matrix:
        configuration: [Release]
    runs-on: windows-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Cache NuGet packages
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: ${{ runner.os }}-nuget-
    - name: Install .NET Core
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x
    - name: Setup MSBuild.exe
      uses: microsoft/setup-msbuild@v2
    - name: Download published output from build
      uses: actions/download-artifact@v4
      with:
        name: release-bits
        path: ${{ github.workspace }}/publish
    # Remove redundant restore/build steps, keep only MSIX-specific build/packaging
    - name: Restore NuGet packages for MSIX packaging
      run: dotnet restore ${{ env.FindNeedleUX_Project }}
    - name: Decode certificate from secret
      run: |
          [System.IO.File]::WriteAllBytes(
            "${{ github.workspace }}/FindNeedleUX/SigningCertificate.pfx",
            [System.Convert]::FromBase64String("${{ secrets.SIGNINGCERTIFICATEENCODED }}")
          )
      shell: pwsh
    - name: Import signing certificate to cert store
      id: import_cert
      run: |
        $pfxPath = "${{ github.workspace }}/FindNeedleUX/SigningCertificate.pfx"
        $securePassword = ConvertTo-SecureString "${{ secrets.SIGNINGCERTIFICATEPASSWORD }}" -AsPlainText -Force
        $cert = Import-PfxCertificate -FilePath $pfxPath -CertStoreLocation Cert:\CurrentUser\My -Password $securePassword
        echo "thumbprint=$($cert.Thumbprint)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
      shell: pwsh
    - name: Create MSIX package (signed)
      run: |
        dotnet publish ${{ env.FindNeedleUX_Project }} --configuration Release --output ${{ github.workspace }}/publish /p:UapAppxPackageBuildMode=StoreUpload /p:GenerateAppxPackageOnBuild=true /p:PackageCertificateThumbprint=${{ steps.import_cert.outputs.thumbprint }}
      shell: pwsh
    - name: Remove signing certificate from cert store
      if: always()
      run: |
        $thumb = "${{ steps.import_cert.outputs.thumbprint }}"
        if ($thumb) {
          $cert = Get-ChildItem -Path Cert:\CurrentUser\My | Where-Object { $_.Thumbprint -eq $thumb }
          if ($cert) {
            Remove-Item -Path $cert.PSPath -Force
            Write-Host "Removed certificate with thumbprint $thumb from store."
          } else {
            Write-Host "Certificate with thumbprint $thumb not found in store."
          }
        } else {
          Write-Host "No thumbprint found, skipping cert removal."
        }
      shell: pwsh
    - name: Upload MSIX artifact (signed)
      uses: actions/upload-artifact@v4
      with:
        name: FindNeedleUX-MSIX
        path: |
          **/AppPackages/**/*.msix
          **/AppPackages/**/*.msixbundle

  make_msix_unsigned:
    needs: [build-release]
    strategy:
      matrix:
        configuration: [Release]
    runs-on: windows-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Cache NuGet packages
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: ${{ runner.os }}-nuget-
    - name: Install .NET Core
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x
    - name: Setup MSBuild.exe
      uses: microsoft/setup-msbuild@v2
    - name: Download published output from build
      uses: actions/download-artifact@v4
      with:
        name: release-bits
        path: ${{ github.workspace }}/publish
    # Remove redundant restore/build steps, keep only MSIX-specific build/packaging
    - name: Restore NuGet packages for MSIX packaging
      run: dotnet restore ${{ env.FindNeedleUX_Project }}
    - name: Create MSIX package (unsigned)
      run: |
        dotnet publish ${{ env.FindNeedleUX_Project }} --configuration Release --output ${{ github.workspace }}/publish /p:UapAppxPackageBuildMode=StoreUpload /p:GenerateAppxPackageOnBuild=true /p:AppxPackageSigningEnabled=false
      shell: pwsh
    - name: Upload MSIX artifact (unsigned)
      uses: actions/upload-artifact@v4
      with:
        name: FindNeedleUX-MSIX-unsigned
        path: |
          **/AppPackages/**/*.msix
          **/AppPackages/**/*.msixbundle


  actually_release:
    needs: [create-release, test-publish]
    if: needs.create-release.result == 'success'
    strategy:
      matrix:
        configuration: [Release]

    runs-on: windows-latest  # For a list of available runner types, refer to
                           # https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on

    steps:
    - name: Check Test Results
      run: |
        echo "Test results must be checked in the test job."

    - name: Download release bits
      uses: actions/download-artifact@v4
      with:
        name: release-bits

    - name: Download signed MSIX artifact
      uses: actions/download-artifact@v4
      with:
        name: FindNeedleUX-MSIX

    - name: Download unsigned MSIX artifact
      uses: actions/download-artifact@v4
      with:
        name: FindNeedleUX-MSIX-unsigned

    # Copy all .msix/.msixbundle files from AppPackages to the root of FindNeedleUX-MSIX-unsigned
    - name: Copy unsigned MSIX files to artifact root
      shell: pwsh
      run: |
        $srcPattern = Join-Path 'FindNeedleUX-MSIX-unsigned' '*/AppPackages/*/*.msix*'
        $files = Get-ChildItem -Path $srcPattern -Recurse -ErrorAction SilentlyContinue
        foreach ($file in $files) {
          Copy-Item $file.FullName -Destination 'FindNeedleUX-MSIX-unsigned' -Force
        }

    - name: List all files in FindNeedleUX-MSIX-unsigned after copying
      shell: pwsh
      run: |
        Write-Host "Listing all .msix and .msixbundle files in the entire workspace after copying MSIX files to root of FindNeedleUX-MSIX-unsigned:"
        Get-ChildItem -Path $env:GITHUB_WORKSPACE -Include *.msix,*.msixbundle -Recurse -ErrorAction SilentlyContinue | ForEach-Object { $_.FullName }
    - name: List all files in FindNeedleUX-MSIX-unsigned after download
      shell: pwsh
      run: |
        Write-Host "Listing all files in FindNeedleUX-MSIX-unsigned after download:"
        Get-ChildItem -Path FindNeedleUX-MSIX-unsigned -Recurse | ForEach-Object { $_.FullName }
    - name: Debug Release Tag
      run: "echo Release tag: ${{needs.create-release.outputs.releasetag}}"

    - name: Ensure release and tag do not already exist
      run: |
        # Install GitHub CLI if not present
        if ! command -v gh > /dev/null; then
          sudo apt-get update && sudo apt-get install -y gh
        fi
        TAG="${{needs.create-release.outputs.releasetag}}"
        if gh release view "$TAG" --repo "$GITHUB_REPOSITORY" > /dev/null 2>&1; then
          echo "Release with tag $TAG exists. Deleting..."
          gh release delete "$TAG" --yes --repo "$GITHUB_REPOSITORY"
        fi
        if git rev-parse "$TAG" >/dev/null 2>&1; then
          echo "Tag $TAG exists. Deleting..."
          git push --delete origin "$TAG" || true
          git tag -d "$TAG" || true
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GITHUB_REPOSITORY: ${{ github.repository }}
      shell: bash

    - name: Create Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{needs.create-release.outputs.releasetag}}
        release_name: Find Needle Beta ${{needs.create-release.outputs.releasetag}}
        draft: false
        prerelease: true
  
  
    - name: Fail if no release.zip found
      shell: pwsh
      run: |
        $files = Get-ChildItem -Path '.' -Recurse -Include release.zip -ErrorAction SilentlyContinue
        Write-Host "Found $($files.Count) release.zip files."
        if ($files.Count -eq 0) {
          Write-Host "::error::No release.zip file found to upload!"
          exit 1
        }
    - name: Upload Release Asset
      id: upload-release-asset 
      uses: sekwah41/upload-release-assets@v1.1.0
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: release.zip
        asset_name: release.zip
        asset_content_type: application/zip

   
    - name: Upload Unsigned MSIX Artifact
      uses: sekwah41/upload-release-assets@v1.1.0
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: '**/AppPackages/**/*.msix'
        asset_name: FindNeedleUX-unsigned.msix
        asset_content_type: application/vnd.ms-appx


    - name: Upload Signed MSIX Artifact
      uses: sekwah41/upload-release-assets@v1.1.0
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: FindNeedleUX-MSIX/*.msix*
        asset_name: FindNeedleUX-signed.msix
        asset_content_type: application/vnd.ms-appx


  test-publish:
    needs: [run-tests, discover-test-projects, build-debug]
    if: always()
    runs-on: ubuntu-latest

    steps:
      - name: Download all coverage artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: coverage-*
          path: coverage-artifacts
      - name: Merge coverage reports
        uses: danielpalme/ReportGenerator-GitHub-Action@5.3.5
        with:
          reports: 'coverage-artifacts/**/coverage.cobertura.xml'
          targetdir: 'merged-coverage'
          reporttypes: 'Cobertura;MarkdownSummary;Badges'
      - name: Publish Code Coverage Report
        uses: irongut/CodeCoverageSummary@v1.3.0
        with:
          filename: 'merged-coverage/Cobertura.xml'
          badge: true
          fail_below_min: false # just informative for now
          format: markdown
          hide_branch_rate: false
          hide_complexity: false
          indicators: true
          output: both
          thresholds: '10 30'
      - name: Write to Job Summary
        run: cat code-coverage-results.md >> $GITHUB_STEP_SUMMARY
    
      - name: Download all test result artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: test-results-*
          path: test-results
      - name: Diagnostic - List all TRX files before publishing
        run: |
          echo "Listing all .trx files in workspace before publishing:"
          Get-ChildItem -Path $env:GITHUB_WORKSPACE -Filter *.trx -Recurse -ErrorAction SilentlyContinue | ForEach-Object { $_.FullName }
        shell: pwsh
      - name: Publish Test Results
        uses: EnricoMi/publish-unit-test-result-action@v2.16.1
        if: always()
        with:
          trx_files: |
            **/*.trx
            */**/TestResults/*.trx
            */**/merged-results/*.trx
            */**/TestResults/**/*.trx
            */**/merged-results/**/*.trx
      - name: Upload coverage badge artifact
        uses: actions/upload-artifact@v4
        with:
          name: coverage-badge
          path: merged-coverage/badge_linecoverage.svg
      - name: Generate test status badge (percentage)
        shell: pwsh
        run: |
          $trxFiles = Get-ChildItem -Path $env:GITHUB_WORKSPACE -Filter *.trx -Recurse -ErrorAction SilentlyContinue
          $total = 0
          $passed = 0
          foreach ($file in $trxFiles) {
            [xml]$xml = Get-Content $file.FullName
            $results = $xml.TestRun.Results.UnitTestResult
            $total += $results.Count
            $passed += ($results | Where-Object { $_.outcome -eq 'Passed' }).Count
          }
          if ($total -eq 0) { $percent = 0 } else { $percent = [math]::Round(($passed / $total) * 100) }
          $color = if ($percent -eq 100) { '#4c1' } elseif ($percent -ge 80) { '#dfb317' } else { '#e05d44' }
          $svg = "<svg xmlns='http://www.w3.org/2000/svg' width='120' height='20'><linearGradient id='b' x2='0' y2='100%'><stop offset='0' stop-color='#bbb' stop-opacity='.1'/><stop offset='1' stop-opacity='.1'/></linearGradient><rect rx='3' width='120' height='20' fill='#555'/><rect rx='3' x='55' width='65' height='20' fill='$color'/><path fill='$color' d='M55 0h4v20h-4z'/><rect rx='3' width='120' height='20' fill='url(#b)'/><g fill='#fff' text-anchor='middle' font-family='Verdana,Geneva,DejaVu Sans,sans-serif' font-size='11'><text x='28' y='15' fill='#010101' fill-opacity='.3'>tests</text><text x='28' y='14'>tests</text><text x='87' y='15' fill='#010101' fill-opacity='.3'>$percent%</text><text x='87' y='14'>$percent%</text></g></svg>"
          $svg | Out-File test-status-percentage.svg -NoNewline
      - name: Upload test status badge artifact (percentage)
        uses: actions/upload-artifact@v4
        with:
          name: test-status-badge
          path: test-status-percentage.svg

  update-badges:
    needs: test-publish
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'
    concurrency:
      group: badges-${{ github.ref }}
      cancel-in-progress: false
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download coverage badge artifact
        uses: actions/download-artifact@v4
        with:
          name: coverage-badge

      - name: Copy coverage badge to .github/badges/coverage.svg
        run: |
          mkdir -p .github/badges
          cp badge_linecoverage.svg .github/badges/coverage.svg

      - name: Commit and push coverage badge
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "github-actions@github.com"
          git fetch origin master
          git checkout master
          git add .github/badges/coverage.svg
          ATTEMPT=1
          MAX_ATTEMPTS=3
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            if git diff --cached --quiet; then
              echo "No changes to commit."
              break
            else
              git commit -m "Update coverage badge [skip ci]" || true
              git pull --rebase origin master || true
              git push "https://${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" master && break
              echo "Push failed (attempt $ATTEMPT/$MAX_ATTEMPTS), retrying after rebase..."
              ATTEMPT=$((ATTEMPT+1))
              sleep 3
              git fetch origin master
              git rebase origin/master || git rebase --skip || true
            fi
          done
          if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
            echo "Failed to push coverage badge after $MAX_ATTEMPTS attempts." >&2
            exit 1
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Download test status badge artifact
        uses: actions/download-artifact@v4
        with:
          name: test-status-badge

      - name: Copy test status badge to .github/badges/test-status.svg
        run: |
          mkdir -p .github/badges
          cp test-status-percentage.svg .github/badges/test-status.svg

      - name: Commit and push test status badge
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "github-actions@github.com"
          git fetch origin master
          git checkout master
          git add .github/badges/test-status.svg
          ATTEMPT=1
          MAX_ATTEMPTS=3
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            if git diff --cached --quiet; then
              echo "No changes to commit."
              break
            else
              git commit -m "Update test status badge [skip ci]" || true
              git pull --rebase origin master || true
              git push "https://${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" master && break
              echo "Push failed (attempt $ATTEMPT/$MAX_ATTEMPTS), retrying after rebase..."
              ATTEMPT=$((ATTEMPT+1))
              sleep 3
              git fetch origin master
              git rebase origin/master || git rebase --skip || true
            fi
          done
          if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
            echo "Failed to push test status badge after $MAX_ATTEMPTS attempts." >&2
            exit 1
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Calculate total test duration and write to file
        shell: pwsh
        run: |
          $trxFiles = Get-ChildItem -Path $env:GITHUB_WORKSPACE -Filter *.trx -Recurse -ErrorAction SilentlyContinue
          $totalSeconds = 0
          foreach ($file in $trxFiles) {
            [xml]$xml = Get-Content $file.FullName
            $results = $xml.TestRun.Results.UnitTestResult
            foreach ($result in $results) {
              $duration = $result.duration
              $startTime = $result.startTime
              $endTime = $result.endTime
              Write-Host "File: $($file.FullName) | duration: $duration | startTime: $startTime | endTime: $endTime"
              if ($duration) {
                $parsed = $false
                try {
                  $ts = [System.TimeSpan]::Parse($duration)
                  $totalSeconds += $ts.TotalSeconds
                  $parsed = $true
                } catch {}
                if (-not $parsed) {
                  try {
                    $totalSeconds += [double]$duration
                    $parsed = $true
                  } catch {
                    Write-Host "Could not parse duration: $duration"
                  }
                }
              } elseif ($startTime -and $endTime) {
                try {
                  $start = [datetime]::Parse($startTime)
                  $end = [datetime]::Parse($endTime)
                  $totalSeconds += ($end - $start).TotalSeconds
                } catch {
                  Write-Host "Could not parse startTime/endTime: $startTime / $endTime"
                }
              } else {
                Write-Host "No duration or start/end time for this result."
              }
            }
          }
          $totalTime = [System.TimeSpan]::FromSeconds($totalSeconds)
          $summary = "Total test time: $($totalTime.ToString())"
          $summary | Out-File .github/badges/test-duration.txt -NoNewline

      - name: Generate test duration badge
        shell: pwsh
        run: |
          $durationText = Get-Content .github/badges/test-duration.txt -Raw
          $duration = $durationText -replace 'Total test time: ', ''
          $badgeValue = $duration.Trim()
          if ($badgeValue -eq '00:00:00') { $badgeValue = '0s' }
          $color = '#007ec6'
          $svg = '<svg xmlns="http://www.w3.org/2000/svg" width="140" height="20"><linearGradient id="b" x2="0" y2="100%"><stop offset="0" stop-color="#bbb" stop-opacity=".1"/><stop offset="1" stop-opacity=".1"/></linearGradient><rect rx="3" width="140" height="20" fill="#555"/><rect rx="3" x="80" width="60" height="20" fill="' + $color + '"/><path fill="' + $color + '" d="M80 0h4v20h-4z"/><rect rx="3" width="140" height="20" fill="url(#b)"/><g fill="#fff" text-anchor="middle" font-family="Verdana,Geneva,DejaVu Sans,sans-serif" font-size="11"><text x="40" y="15" fill="#010101" fill-opacity=".3">test duration</text><text x="40" y="14">test duration</text><text x="110" y="15" fill="#010101" fill-opacity=".3">' + $badgeValue + '</text><text x="110" y="14">' + $badgeValue + '</text></g></svg>'
          $svg | Out-File .github/badges/test-duration.svg -NoNewline

      - name: Commit and push test duration badge
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "github-actions@github.com"
          git fetch origin master
          git checkout master
          git add .github/badges/test-duration.svg
          ATTEMPT=1
          MAX_ATTEMPTS=3
          while [ $ATTEMPT -le $MAX_ATTEMPTS ]; do
            if git diff --cached --quiet; then
              echo "No changes to commit."
              break
            else
              git commit -m "Update test duration badge [skip ci]" || true
              git pull --rebase origin master || true
              git push "https://${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" master && break
              echo "Push failed (attempt $ATTEMPT/$MAX_ATTEMPTS), retrying after rebase..."
              ATTEMPT=$((ATTEMPT+1))
              sleep 3
              git fetch origin master
              git rebase origin/master || git rebase --skip || true
            fi
          done
          if [ $ATTEMPT -gt $MAX_ATTEMPTS ]; then
            echo "Failed to push test duration badge after $MAX_ATTEMPTS attempts." >&2
            exit 1
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  run-tests:
    needs: [discover-test-projects, build-debug]
    strategy:
      matrix:
        test_project: ${{ fromJson(needs.discover-test-projects.outputs.test_projects) }}
    runs-on: windows-latest
    outputs:
      testresult: ${{ steps.testrun.outcome }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Cache NuGet packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: ${{ runner.os }}-nuget-
      - name: Install .NET Core
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x
      - name: Setup MSBuild.exe
        uses: microsoft/setup-msbuild@v2
      - name: Download build outputs
        uses: actions/download-artifact@v4
        with:
          name: build-output-Debug
          path: .
      - name: Restore NuGet packages for test project
        shell: pwsh
        run: |
          dotnet restore ${{ matrix.test_project }}
      - name: Fail if test project does not exist
        shell: pwsh
        run: |
          if (-not (Test-Path "${{ matrix.test_project }}")) {
            Write-Host "Test project ${{ matrix.test_project }} was not built or does not exist. Failing."
            exit 1
          }
      - name: List test DLLs in output directory
        shell: pwsh
        run: |
          $projName = [System.IO.Path]::GetFileNameWithoutExtension("${{ matrix.test_project }}")
          $projDir = Split-Path -Parent "${{ matrix.test_project }}"
          $dllPath = Join-Path $projDir "bin/x64/Debug/net8.0-windows10.0.19041.0/win-x64"
          Write-Host "Listing DLLs in $dllPath for $projName"
          if (Test-Path $dllPath) {
            Get-ChildItem -Path $dllPath -Filter "*.dll" | ForEach-Object { $_.FullName }
          } else {
            Write-Host "Directory $dllPath does not exist!"
          }
      - name: List test DLLs before running tests (diagnostic)
        shell: pwsh
        run: |
          $projPath = "${{ matrix.test_project }}"
          $projDir = Split-Path $projPath -Parent
          $dllName = (Split-Path $projPath -LeafBase) + ".dll"
          $outDir = Join-Path $projDir "bin/x64/Debug/net8.0-windows10.0.19041.0/win-x64"
          Write-Host "Looking for test DLL: $dllName in ${outDir}"
          if (Test-Path $outDir) {
            Get-ChildItem -Path $outDir -Filter $dllName -Recurse | ForEach-Object { $_.FullName }
            Write-Host "Directory listing for ${outDir}:"
            Get-ChildItem -Path $outDir -Recurse | ForEach-Object { $_.FullName }
          } else {
            Write-Host "Output directory ${outDir} does not exist."
          }
      - name: Run tests and collect coverage
        id: testrun
        continue-on-error: true
        run: |
          dotnet test ${{ matrix.test_project }} --configuration Debug --no-build --logger trx --collect:"XPlat Code Coverage" --framework net8.0-windows10.0.19041.0
      - name: Set Safe Artifact Name
        id: safe_name
        shell: pwsh
        run: |
          $SAFE_NAME = "${{ matrix.test_project }}"
          $SAFE_NAME = $SAFE_NAME -replace '/', '-'
          $SAFE_NAME = $SAFE_NAME -replace '\\', '-'
          echo "safe_name=$SAFE_NAME" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
      - name: Upload Test Result Files
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ steps.safe_name.outputs.safe_name }}
          path: ${{ github.workspace }}/**/TestResults/**/*.trx
          retention-days: 5
      - name: Upload Coverage XML
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ steps.safe_name.outputs.safe_name }}
          path: ${{ github.workspace }}/**/TestResults/**/coverage.cobertura.xml
          retention-days: 5
      - name: Diagnostic - List all coverage.cobertura.xml files in workspace
        shell: pwsh
        run: |
          Write-Host "Searching for all coverage.cobertura.xml files in workspace:"
          Get-ChildItem -Path $env:GITHUB_WORKSPACE -Filter coverage.cobertura.xml -Recurse -ErrorAction SilentlyContinue | ForEach-Object { $_.FullName }
      - name: Diagnostic - List all coverage.cobertura.xml files after test run
        shell: pwsh
        run: |
          Write-Host "Searching for coverage.cobertura.xml files in workspace after test run:"
          Get-ChildItem -Path ${{ github.workspace }} -Filter coverage.cobertura.xml -Recurse -ErrorAction SilentlyContinue | ForEach-Object { $_.FullName }
      - name: Diagnostic - List all files in TestResults after test run
        shell: pwsh
        run: |
          $projDir = Split-Path "${{ matrix.test_project }}" -Parent
          $testResultsDir = Join-Path $projDir "bin/x64/Debug/net8.0-windows10.0.19041.0/win-x64/TestResults"
          Write-Host "Listing all files in $testResultsDir (if exists):"
          if (Test-Path $testResultsDir) {
            Get-ChildItem -Path $testResultsDir -Recurse -ErrorAction SilentlyContinue | ForEach-Object { $_.FullName }
            Write-Host ""
            Write-Host "Contents of .log and .xml files in ${testResultsDir}:"
            Get-ChildItem -Path $testResultsDir -Recurse -Include *.log,*.xml -ErrorAction SilentlyContinue | ForEach-Object {
              Write-Host "--- $($_.FullName) ---"
              Get-Content $_.FullName | Write-Host
            }
          } else {
            Write-Host "TestResults directory does not exist."
          }
      - name: Diagnostic - List all TRX files before publishing
        run: |
          echo "Listing all .trx files in workspace before publishing:"
          Get-ChildItem -Path $env:GITHUB_WORKSPACE -Filter *.trx -Recurse -ErrorAction SilentlyContinue | ForEach-Object { $_.FullName }
        shell: pwsh
      - name: Diagnostic - List and print all TRX files before calculating duration
        shell: pwsh
        run: |
          $trxFiles = Get-ChildItem -Path $env:GITHUB_WORKSPACE -Filter *.trx -Recurse -ErrorAction SilentlyContinue
          if ($trxFiles.Count -eq 0) {
            Write-Host "No .trx files found in workspace!"
          } else {
            foreach ($file in $trxFiles) {
              Write-Host "--- $($file.FullName) ---"
              Get-Content $file.FullName | Write-Host
            }
          }
