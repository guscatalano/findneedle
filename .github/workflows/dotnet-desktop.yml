# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# This workflow will build, test, sign and package a WPF or Windows Forms desktop application
# built on .NET Core.
# To learn how to migrate your existing application to .NET Core,
# refer to https://docs.microsoft.com/en-us/dotnet/desktop-wpf/migration/convert-project-from-net-framework
#
# To configure this workflow:
#
# 1. Configure environment variables
# GitHub sets default environment variables for every workflow run.
# Replace the variables relative to your project in the "env" section below.
#
# 2. Signing
# Generate a signing certificate in the Windows Application
# Packaging Project or add an existing signing certificate to the project.
# Next, use PowerShell to encode the .pfx file using Base64 encoding
# by running the following Powershell script to generate the output string:
#
# $pfx_cert = Get-Content '.\SigningCertificate.pfx' -Encoding Byte
# [System.Convert]::ToBase64String($pfx_cert) | Out-File 'SigningCertificate_Encoded.txt'
#
# Open the output file, SigningCertificate_Encoded.txt, and copy the
# string inside. Then, add the string to the repo as a GitHub secret
# and name it "Base64_Encoded_Pfx."
# For more information on how to configure your signing certificate for
# this workflow, refer to https://github.com/microsoft/github-actions-for-desktop-apps#signing
#
# Finally, add the signing certificate password to the repo as a secret and name it "Pfx_Key".
# See "Build the Windows Application Packaging project" below to see how the secret is used.
#
# For more information on GitHub Actions, refer to https://github.com/features/actions
# For a complete CI/CD sample to get started with GitHub Action workflows for Desktop Applications,
# refer to https://github.com/microsoft/github-actions-for-desktop-apps

name: .NET Core Desktop

permissions:
  contents: write
  checks: write

on:
  push:
    branches: [ "master" ]
    tags:
      - 'v*.*.*'

  pull_request:
    branches: [ "master" ]

env:
  Solution_Name: findneedle.sln
  FindNeedleUX_Project: FindNeedleUX/FindNeedleUX.csproj
  GH_TOKEN: ${{ github.token }}

jobs:
  create-release:
    needs: [build-release, test-publish]
    if: needs.test-publish.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      releasetag: ${{ steps.currenttag.outputs.tag }}

    steps:
    - name: Check Test Results
      run: |
        echo "Test results must be checked in the test job."

    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # Get changed files for this commit (must be before any step that uses its output)
    - name: Get changed files
      id: get_changed_files
      uses: tj-actions/changed-files@v46
      with:
        separator: ','

    # Remove older tags and releases if more than 50 exist (skip if workflow changed)
    - name: Remove older tags and releases if more than 50 exist (skip if workflow changed)
      if: github.ref == 'refs/heads/master' && !contains(join(steps.get_changed_files.outputs.all_changed_files, ','), '.github/workflows/dotnet-desktop.yml')
      id: remove_old_tags
      run: |
        $ErrorActionPreference = 'Stop'
        # Install GitHub CLI if not present
        if (-not (Get-Command gh -ErrorAction SilentlyContinue)) {
          Invoke-WebRequest -Uri "https://github.com/cli/cli/releases/download/v2.49.0/gh_2.49.0_windows_amd64.zip" -OutFile "ghcli.zip"
          Expand-Archive ghcli.zip -DestinationPath ghcli
          $env:Path += ";$pwd\ghcli\gh_2.49.0_windows_amd64\bin"
        }
        $tags = git tag --sort=-creatordate
        $tagCount = ($tags | Measure-Object -Line).Lines
        if ($tagCount -gt 50) {
          $tagsToDelete = $tags | Select-Object -Skip 50
          foreach ($tag in $tagsToDelete) {
            Write-Host "Deleting old tag: $tag"
            git tag -d $tag
            git push --delete origin $tag
            try {
              gh release delete $tag --yes
              Write-Host "Deleted release for tag: $tag"
            } catch {
              Write-Host "No release found for tag: $tag or failed to delete."
            }
          }
        } else {
          Write-Host "Tag count ($tagCount) is 50 or less. No tags or releases deleted."
        }
      shell: pwsh

    # Only create a release/tag if workflow file was not changed
    - name: Create an incremental release (skip if workflow changed)
      if: github.ref == 'refs/heads/master' && !contains(join(steps.get_changed_files.outputs.all_changed_files, ','), '.github/workflows/dotnet-desktop.yml')
      uses: aurestic/incrementarl-create-release@master
      with:
        flag_branch: true
        message: Bump version
        prev_tag: 'v'
        update_odoo_module_version: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    # Get Previous tag
    - name: 'Get Previous tag'
      id: currenttag
      uses: "WyriHaximus/github-action-get-previous-tag@v1"
      with:
        fallback: 1.0.0 # Optional fallback tag to use when no tag can be found
        #workingDirectory: another/path/where/a/git/repo/is/checked/out # Optional alternative working directory

  discover-test-projects:
    runs-on: ubuntu-latest
    outputs:
      test_projects: ${{ steps.find-tests.outputs.test_projects }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Find all test projects
        id: find-tests
        run: |
          # Find all .csproj files that look like test projects (by convention, in folders ending with 'Tests')
          TEST_PROJECTS=$(find . -type f -name "*.csproj" | grep -i 'Tests/' | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "Found test projects: $TEST_PROJECTS"
          echo "::notice::Discovered test projects: $TEST_PROJECTS"
          if [ "$TEST_PROJECTS" = "[]" ]; then
            echo "::error::No test projects discovered. Failing the job."
            exit 1
          fi
          echo "test_projects=$TEST_PROJECTS" >> $GITHUB_OUTPUT
      - name: Write discovered test projects to file
        run: |
          echo '${{ steps.find-tests.outputs.test_projects }}' > test-projects.json
      - name: Upload discovered test project list
        uses: actions/upload-artifact@v4
        with:
          name: test-projects-list
          path: test-projects.json

  build-debug:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Cache NuGet packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: ${{ runner.os }}-nuget-
      - name: Restore dependencies
        run: dotnet restore ${{ env.Solution_Name }}
      - name: Build solution (Debug)
        run: dotnet build ${{ env.Solution_Name }} --configuration Debug --no-restore
      - name: Publish all projects (Debug, x64)
        run: |
          for %%f in (*.csproj) do (
            for /f "usebackq tokens=*" %%t in (`powershell -Command "try { (Select-String -Path '%%f' -Pattern '<TargetFramework>(.+)</TargetFramework>' | Select-Object -First 1).Matches[0].Groups[1].Value } catch { '' }"`) do (
              if not "%%t"=="" dotnet publish "%%f" --configuration Debug --framework %%t --output "%%~dpfbin\x64\Debug\publish" --runtime win-x64 /p:Platform=x64
            )
          )
          for %%f in (*\*.csproj) do (
            for /f "usebackq tokens=*" %%t in (`powershell -Command "try { (Select-String -Path '%%f' -Pattern '<TargetFramework>(.+)</TargetFramework>' | Select-Object -First 1).Matches[0].Groups[1].Value } catch { '' }"`) do (
              if not "%%t"=="" dotnet publish "%%f" --configuration Debug --framework %%t --output "%%~dpfbin\x64\Debug\publish" --runtime win-x64 /p:Platform=x64
            )
          )
          for %%f in (*\*\*.csproj) do (
            for /f "usebackq tokens=*" %%t in (`powershell -Command "try { (Select-String -Path '%%f' -Pattern '<TargetFramework>(.+)</TargetFramework>' | Select-Object -First 1).Matches[0].Groups[1].Value } catch { '' }"`) do (
              if not "%%t"=="" dotnet publish "%%f" --configuration Debug --framework %%t --output "%%~dpfbin\x64\Debug\publish" --runtime win-x64 /p:Platform=x64
            )
          )
        shell: cmd
      - name: Download discovered test project list
        uses: actions/download-artifact@v4
        with:
          name: test-projects-list
          path: .
      - name: Build all discovered test projects (Debug, x64, net8.0-windows10.0.19041.0)
        shell: pwsh
        run: |
          $testProjects = Get-Content test-projects.json | ConvertFrom-Json
          foreach ($proj in $testProjects) {
            Write-Host "Building test project: $proj"
            dotnet build $proj --configuration Debug --framework net8.0-windows10.0.19041.0
          }
      - name: Diagnostic - List all discovered test project bin folders after build
        shell: pwsh
        run: |
          $testProjects = Get-Content test-projects.json | ConvertFrom-Json
          foreach ($proj in $testProjects) {
            $bindir = Join-Path (Split-Path $proj -Parent) 'bin'
            Write-Host "Project: $proj"
            Get-ChildItem -Path $bindir -Recurse -ErrorAction SilentlyContinue | Write-Host
          }
      - name: Diagnostic - List all test project csproj files
        run: |
          echo Listing all test project csproj files:
          dir /b /s *.csproj | findstr /i Tests
        shell: cmd
      - name: Diagnostic - Build each test project and echo output
        run: |
          for %%f in (*Tests\*.csproj) do (
            echo Building %%f ...
            dotnet build "%%f" --configuration Debug --framework net8.0-windows10.0.19041.0 --runtime win-x64 --output "%%~dpfbin\x64\Debug\net8.0-windows10.0.19041.0\win-x64" /p:Platform=x64
            echo Result for %%f: %ERRORLEVEL%
          )
        shell: cmd
      - name: Diagnostic - List all publish folders and contents before upload
        shell: pwsh
        run: |
          Write-Host "Listing all publish folders and their contents before artifact upload:"
          Get-ChildItem -Path . -Recurse -Directory -Filter publish | ForEach-Object {
            Write-Host "Found publish folder: $($_.FullName)"
            Get-ChildItem -Path $_.FullName -Recurse | ForEach-Object { Write-Host $_.FullName }
          }
      - name: Upload all build outputs (Debug)
        uses: actions/upload-artifact@v4
        with:
          name: build-output-Debug
          path: .
          retention-days: 2
          

  build-release:
    runs-on: windows-latest
    strategy:
      matrix:
        platform: [x64]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Cache NuGet packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: ${{ runner.os }}-nuget-
      - name: Restore dependencies
        run: dotnet restore ${{ env.Solution_Name }}
      - name: Build solution (Release, ${{ matrix.platform }})
        run: dotnet build ${{ env.Solution_Name }} --configuration Release --no-restore /p:Platform=${{ matrix.platform }}
      - name: Publish FindNeedleUX (Release only, x64)
        if: matrix.platform == 'x64'
        run: dotnet publish ${{ env.FindNeedleUX_Project }} --configuration Release --output ${{ github.workspace }}/publish /p:Platform=x64
      - name: Archive Release (Release only, x64)
        if: matrix.platform == 'x64'
        uses: thedoctor0/zip-release@0.7.5
        with:
          type: 'zip'
          directory: '${{ github.workspace }}/publish'
          filename: 'release.zip'
          exclusions: '*.git* /*node_modules/*.editorconfig'
      - name: Upload Release bits (Release only, x64)
        if: matrix.platform == 'x64'
        uses: actions/upload-artifact@v4
        with:
          name: release-bits
          path: ${{ github.workspace }}/publish/release.zip
          retention-days: 5

  make_msix_signed:
    needs: [build-release]
    strategy:
      matrix:
        configuration: [Release]
    runs-on: windows-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Cache NuGet packages
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: ${{ runner.os }}-nuget-
    - name: Install .NET Core
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x
    - name: Setup MSBuild.exe
      uses: microsoft/setup-msbuild@v2
    - name: Download published output from build
      uses: actions/download-artifact@v4
      with:
        name: release-bits
        path: ${{ github.workspace }}/publish
    # Remove redundant restore/build steps, keep only MSIX-specific build/packaging
    - name: Restore NuGet packages for MSIX packaging
      run: dotnet restore ${{ env.FindNeedleUX_Project }}
    - name: Decode certificate from secret
      run: |
          [System.IO.File]::WriteAllBytes(
            "${{ github.workspace }}/FindNeedleUX/SigningCertificate.pfx",
            [System.Convert]::FromBase64String("${{ secrets.SIGNINGCERTIFICATEENCODED }}")
          )
      shell: pwsh
    - name: Import signing certificate to cert store
      id: import_cert
      run: |
        $pfxPath = "${{ github.workspace }}/FindNeedleUX/SigningCertificate.pfx"
        $securePassword = ConvertTo-SecureString "${{ secrets.SIGNINGCERTIFICATEPASSWORD }}" -AsPlainText -Force
        $cert = Import-PfxCertificate -FilePath $pfxPath -CertStoreLocation Cert:\CurrentUser\My -Password $securePassword
        echo "thumbprint=$($cert.Thumbprint)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
      shell: pwsh
    - name: Create MSIX package (signed)
      run: |
        dotnet publish ${{ env.FindNeedleUX_Project }} --configuration Release --output ${{ github.workspace }}/publish /p:UapAppxPackageBuildMode=StoreUpload /p:GenerateAppxPackageOnBuild=true /p:PackageCertificateThumbprint=${{ steps.import_cert.outputs.thumbprint }}
      shell: pwsh
    - name: Remove signing certificate from cert store
      if: always()
      run: |
        $thumb = "${{ steps.import_cert.outputs.thumbprint }}"
        if ($thumb) {
          $cert = Get-ChildItem -Path Cert:\CurrentUser\My | Where-Object { $_.Thumbprint -eq $thumb }
          if ($cert) {
            Remove-Item -Path $cert.PSPath -Force
            Write-Host "Removed certificate with thumbprint $thumb from store."
          } else {
            Write-Host "Certificate with thumbprint $thumb not found in store."
          }
        } else {
          Write-Host "No thumbprint found, skipping cert removal."
        }
      shell: pwsh
    - name: Upload MSIX artifact (signed)
      uses: actions/upload-artifact@v4
      with:
        name: FindNeedleUX-MSIX
        path: |
          **/AppPackages/**/*.msix
          **/AppPackages/**/*.msixbundle

  make_msix_unsigned:
    needs: [build-release]
    strategy:
      matrix:
        configuration: [Release]
    runs-on: windows-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Cache NuGet packages
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: ${{ runner.os }}-nuget-
    - name: Install .NET Core
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x
    - name: Setup MSBuild.exe
      uses: microsoft/setup-msbuild@v2
    - name: Download published output from build
      uses: actions/download-artifact@v4
      with:
        name: release-bits
        path: ${{ github.workspace }}/publish
    # Remove redundant restore/build steps, keep only MSIX-specific build/packaging
    - name: Restore NuGet packages for MSIX packaging
      run: dotnet restore ${{ env.FindNeedleUX_Project }}
    - name: Create MSIX package (unsigned)
      run: |
        dotnet publish ${{ env.FindNeedleUX_Project }} --configuration Release --output ${{ github.workspace }}/publish /p:UapAppxPackageBuildMode=StoreUpload /p:GenerateAppxPackageOnBuild=true /p:AppxPackageSigningEnabled=false
      shell: pwsh
    - name: Upload MSIX artifact (unsigned)
      uses: actions/upload-artifact@v4
      with:
        name: FindNeedleUX-MSIX-unsigned
        path: |
          **/AppPackages/**/*.msix
          **/AppPackages/**/*.msixbundle


  actually_release:
    needs: [create-release, test-publish]
    if: needs.create-release.result == 'success'
    strategy:
      matrix:
        configuration: [Release]

    runs-on: windows-latest  # For a list of available runner types, refer to
                           # https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on

    steps:
    - name: Check Test Results
      run: |
        echo "Test results must be checked in the test job."

    - name: Download release bits
      uses: actions/download-artifact@v4
      with:
        name: release-bits

    - name: Download signed MSIX artifact
      uses: actions/download-artifact@v4
      with:
        name: FindNeedleUX-MSIX

    - name: Download unsigned MSIX artifact
      uses: actions/download-artifact@v4
      with:
        name: FindNeedleUX-MSIX-unsigned

    - name: Debug Release Tag
      run: "echo Release tag: ${{needs.create-release.outputs.releasetag}}"

    - name: Ensure release and tag do not already exist
      run: |
        # Install GitHub CLI if not present
        if ! command -v gh > /dev/null; then
          sudo apt-get update && sudo apt-get install -y gh
        fi
        TAG="${{needs.create-release.outputs.releasetag}}"
        if gh release view "$TAG" --repo "$GITHUB_REPOSITORY" > /dev/null 2>&1; then
          echo "Release with tag $TAG exists. Deleting..."
          gh release delete "$TAG" --yes --repo "$GITHUB_REPOSITORY"
        fi
        if git rev-parse "$TAG" >/dev/null 2>&1; then
          echo "Tag $TAG exists. Deleting..."
          git push --delete origin "$TAG" || true
          git tag -d "$TAG" || true
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GITHUB_REPOSITORY: ${{ github.repository }}
      shell: bash

    - name: Create Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{needs.create-release.outputs.releasetag}}
        release_name: Find Needle Beta ${{needs.create-release.outputs.releasetag}}
        draft: false
        prerelease: true
  
  
    - name: Upload Release Asset
      id: upload-release-asset 
      uses: sekwah41/upload-release-assets@v1.1.0
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: release.zip
        asset_name: release.zip
        asset_content_type: application/zip

    - name: Upload Signed MSIX Artifact
      uses: sekwah41/upload-release-assets@v1.1.0
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: FindNeedleUX-MSIX/*.msix
        asset_name: FindNeedleUX-signed.msix
        asset_content_type: application/vnd.ms-appx

    - name: Upload Unsigned MSIX Artifact
      uses: sekwah41/upload-release-assets@v1.1.0
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: FindNeedleUX-MSIX-unsigned/*.msix
        asset_name: FindNeedleUX-unsigned.msix
        asset_content_type: application/vnd.ms-appx


  test-publish:
    needs: run-tests
    if: always()
    strategy:
      matrix:
        configuration: [Debug]
    runs-on: ubuntu-latest

    steps:
      - name: Download all coverage artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: coverage-*
          path: coverage-artifacts
      - name: Merge coverage reports
        uses: danielpalme/ReportGenerator-GitHub-Action@5.3.5
        with:
          reports: 'coverage-artifacts/**/coverage.cobertura.xml'
          targetdir: 'merged-coverage'
          reporttypes: 'Cobertura;MarkdownSummary;Badges'
      - name: Publish Code Coverage Report
        uses: irongut/CodeCoverageSummary@v1.3.0
        with:
          filename: 'merged-coverage/Cobertura.xml'
          badge: true
          fail_below_min: false # just informative for now
          format: markdown
          hide_branch_rate: false
          hide_complexity: false
          indicators: true
          output: both
          thresholds: '10 30'
      - name: Write to Job Summary
        run: cat code-coverage-results.md >> $GITHUB_STEP_SUMMARY
    
      - name: Download all test result artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: test-results-*
          path: test-results
      - name: Diagnostic - List all TRX files before publishing
        run: |
          echo "Listing all .trx files in workspace before publishing:"
          Get-ChildItem -Path $env:GITHUB_WORKSPACE -Filter *.trx -Recurse -ErrorAction SilentlyContinue | ForEach-Object { $_.FullName }
        shell: pwsh
      - name: Publish Test Results
        uses: EnricoMi/publish-unit-test-result-action@v2.16.1
        if: always()
        with:
          trx_files: |
            **/*.trx
            */**/TestResults/*.trx
            */**/merged-results/*.trx
            */**/TestResults/**/*.trx
            */**/merged-results/**/*.trx
      - name: Upload coverage badge artifact
        uses: actions/upload-artifact@v4
        with:
          name: coverage-badge
          path: merged-coverage/badge_linecoverage.svg
      - name: Generate test status badge (percentage)
        shell: pwsh
        run: |
          $trxFiles = Get-ChildItem -Path $env:GITHUB_WORKSPACE -Filter *.trx -Recurse -ErrorAction SilentlyContinue
          $total = 0
          $passed = 0
          foreach ($file in $trxFiles) {
            [xml]$xml = Get-Content $file.FullName
            $results = $xml.TestRun.Results.UnitTestResult
            $total += $results.Count
            $passed += ($results | Where-Object { $_.outcome -eq 'Passed' }).Count
          }
          if ($total -eq 0) { $percent = 0 } else { $percent = [math]::Round(($passed / $total) * 100) }
          $color = if ($percent -eq 100) { '#4c1' } elseif ($percent -ge 80) { '#dfb317' } else { '#e05d44' }
          $svg = "<svg xmlns='http://www.w3.org/2000/svg' width='120' height='20'><linearGradient id='b' x2='0' y2='100%'><stop offset='0' stop-color='#bbb' stop-opacity='.1'/><stop offset='1' stop-opacity='.1'/></linearGradient><rect rx='3' width='120' height='20' fill='#555'/><rect rx='3' x='55' width='65' height='20' fill='$color'/><path fill='$color' d='M55 0h4v20h-4z'/><rect rx='3' width='120' height='20' fill='url(#b)'/><g fill='#fff' text-anchor='middle' font-family='Verdana,Geneva,DejaVu Sans,sans-serif' font-size='11'><text x='28' y='15' fill='#010101' fill-opacity='.3'>tests</text><text x='28' y='14'>tests</text><text x='87' y='15' fill='#010101' fill-opacity='.3'>$percent%</text><text x='87' y='14'>$percent%</text></g></svg>"
          $svg | Out-File test-status-percentage.svg -NoNewline
      - name: Upload test status badge artifact (percentage)
        uses: actions/upload-artifact@v4
        with:
          name: test-status-badge
          path: test-status-percentage.svg

  update-badges:
    needs: test-publish
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download coverage badge artifact
        uses: actions/download-artifact@v4
        with:
          name: coverage-badge

      - name: Copy coverage badge to .github/badges/coverage.svg
        run: |
          mkdir -p .github/badges
          cp badge_linecoverage.svg .github/badges/coverage.svg

      - name: Commit and push coverage badge
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "github-actions@github.com"
          git fetch origin master
          git checkout master
          git add .github/badges/coverage.svg
          if git diff --cached --quiet; then
            echo "No changes to commit."
          else
            git commit -m "Update coverage badge [skip ci]"
            git push "https://${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" master
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  run-tests:
    needs: [discover-test-projects, build-debug]
    if: needs.build-debug.result == 'success'
    strategy:
      matrix:
        test_project: ${{ fromJson(needs.discover-test-projects.outputs.test_projects) }}
    runs-on: windows-latest
    outputs:
      testresult: ${{ steps.testrun.outcome }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Cache NuGet packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: ${{ runner.os }}-nuget-
      - name: Install .NET Core
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x
      - name: Setup MSBuild.exe
        uses: microsoft/setup-msbuild@v2
      - name: Download build outputs
        uses: actions/download-artifact@v4
        with:
          name: build-output-Debug
          path: .
      - name: Restore NuGet packages for test project
        shell: pwsh
        run: |
          dotnet restore ${{ matrix.test_project }}
      - name: Fail if test project does not exist
        shell: pwsh
        run: |
          if (-not (Test-Path "${{ matrix.test_project }}")) {
            Write-Host "Test project ${{ matrix.test_project }} was not built or does not exist. Failing."
            exit 1
          }
      - name: List test DLLs in output directory
        shell: pwsh
        run: |
          $projName = [System.IO.Path]::GetFileNameWithoutExtension("${{ matrix.test_project }}")
          $projDir = Split-Path -Parent "${{ matrix.test_project }}"
          $dllPath = Join-Path $projDir "bin/x64/Debug/net8.0-windows10.0.19041.0/win-x64"
          Write-Host "Listing DLLs in $dllPath for $projName"
          if (Test-Path $dllPath) {
            Get-ChildItem -Path $dllPath -Filter "*.dll" | ForEach-Object { $_.FullName }
          } else {
            Write-Host "Directory $dllPath does not exist!"
          }
      - name: List test DLLs before running tests (diagnostic)
        shell: pwsh
        run: |
          $projPath = "${{ matrix.test_project }}"
          $projDir = Split-Path $projPath -Parent
          $dllName = (Split-Path $projPath -LeafBase) + ".dll"
          $outDir = Join-Path $projDir "bin/x64/Debug/net8.0-windows10.0.19041.0/win-x64"
          Write-Host "Looking for test DLL: $dllName in ${outDir}"
          if (Test-Path $outDir) {
            Get-ChildItem -Path $outDir -Filter $dllName -Recurse | ForEach-Object { $_.FullName }
            Write-Host "Directory listing for ${outDir}:"
            Get-ChildItem -Path $outDir -Recurse | ForEach-Object { $_.FullName }
          } else {
            Write-Host "Output directory ${outDir} does not exist."
          }
      - name: Run tests and collect coverage
        id: testrun
        continue-on-error: true
        run: |
          dotnet test ${{ matrix.test_project }} --configuration Debug --no-build --logger trx --collect:"XPlat Code Coverage" --framework net8.0-windows10.0.19041.0
      - name: Set Safe Artifact Name
        id: safe_name
        shell: pwsh
        run: |
          $SAFE_NAME = "${{ matrix.test_project }}"
          $SAFE_NAME = $SAFE_NAME -replace '/', '-'
          $SAFE_NAME = $SAFE_NAME -replace '\\', '-'
          echo "safe_name=$SAFE_NAME" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
      - name: Upload Test Result Files
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ steps.safe_name.outputs.safe_name }}
          path: ${{ github.workspace }}/**/TestResults/**/*.trx
          retention-days: 5
      - name: Upload Coverage XML
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ steps.safe_name.outputs.safe_name }}
          path: ${{ github.workspace }}/**/TestResults/**/coverage.cobertura.xml
          retention-days: 5
      - name: Diagnostic - List all coverage.cobertura.xml files in workspace
        shell: pwsh
        run: |
          Write-Host "Searching for all coverage.cobertura.xml files in workspace:"
          Get-ChildItem -Path $env:GITHUB_WORKSPACE -Filter coverage.cobertura.xml -Recurse -ErrorAction SilentlyContinue | ForEach-Object { $_.FullName }
      - name: Diagnostic - List all coverage.cobertura.xml files after test run
        shell: pwsh
        run: |
          Write-Host "Searching for coverage.cobertura.xml files in workspace after test run:"
          Get-ChildItem -Path ${{ github.workspace }} -Filter coverage.cobertura.xml -Recurse -ErrorAction SilentlyContinue | ForEach-Object { $_.FullName }
      - name: Diagnostic - List all files in TestResults after test run
        shell: pwsh
        run: |
          $projDir = Split-Path "${{ matrix.test_project }}" -Parent
          $testResultsDir = Join-Path $projDir "bin/x64/Debug/net8.0-windows10.0.19041.0/win-x64/TestResults"
          Write-Host "Listing all files in $testResultsDir (if exists):"
          if (Test-Path $testResultsDir) {
            Get-ChildItem -Path $testResultsDir -Recurse -ErrorAction SilentlyContinue | ForEach-Object { $_.FullName }
            Write-Host ""
            Write-Host "Contents of .log and .xml files in ${testResultsDir}:"
            Get-ChildItem -Path $testResultsDir -Recurse -Include *.log,*.xml -ErrorAction SilentlyContinue | ForEach-Object {
              Write-Host "--- $($_.FullName) ---"
              Get-Content $_.FullName | Write-Host
            }
          } else {
            Write-Host "TestResults directory does not exist."
          }
      - name: Diagnostic - List all TRX files before publishing
        run: |
          echo "Listing all .trx files in workspace before publishing:"
          Get-ChildItem -Path $env:GITHUB_WORKSPACE -Filter *.trx -Recurse -ErrorAction SilentlyContinue | ForEach-Object { $_.FullName }
        shell: pwsh
