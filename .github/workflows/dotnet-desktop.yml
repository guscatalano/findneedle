# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# This workflow will build, test, sign and package a WPF or Windows Forms desktop application
# built on .NET Core.
# To learn how to migrate your existing application to .NET Core,
# refer to https://docs.microsoft.com/en-us/dotnet/desktop-wpf/migration/convert-project-from-net-framework
#
# To configure this workflow:
#
# 1. Configure environment variables
# GitHub sets default environment variables for every workflow run.
# Replace the variables relative to your project in the "env" section below.
#
# 2. Signing
# Generate a signing certificate in the Windows Application
# Packaging Project or add an existing signing certificate to the project.
# Next, use PowerShell to encode the .pfx file using Base64 encoding
# by running the following Powershell script to generate the output string:
#
# $pfx_cert = Get-Content '.\SigningCertificate.pfx' -Encoding Byte
# [System.Convert]::ToBase64String($pfx_cert) | Out-File 'SigningCertificate_Encoded.txt'
#
# Open the output file, SigningCertificate_Encoded.txt, and copy the
# string inside. Then, add the string to the repo as a GitHub secret
# and name it "Base64_Encoded_Pfx."
# For more information on how to configure your signing certificate for
# this workflow, refer to https://github.com/microsoft/github-actions-for-desktop-apps#signing
#
# Finally, add the signing certificate password to the repo as a secret and name it "Pfx_Key".
# See "Build the Windows Application Packaging project" below to see how the secret is used.
#
# For more information on GitHub Actions, refer to https://github.com/features/actions
# For a complete CI/CD sample to get started with GitHub Action workflows for Desktop Applications,
# refer to https://github.com/microsoft/github-actions-for-desktop-apps

name: .NET Core Desktop

on:
  push:
    branches: [ "master" ]
    tags:
      - 'v*.*.*'

  pull_request:
    branches: [ "master" ]

env:
  Solution_Name: findneedle.sln
  FindNeedleUX_Project: FindNeedleUX/FindNeedleUX.csproj
  GH_TOKEN: ${{ github.token }}

jobs:
  create-release:
    needs: [build, run-tests, test-publish]
    runs-on: ubuntu-latest
    outputs:
      releasetag: ${{ steps.currenttag.outputs.tag }}

    steps:
    - name: Check Test Results
      if: ${{ needs.run-tests.outputs.testresult != 'success' }}
      run: |
        echo "Tests failed. Failing the job."
        exit 1

    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # Get changed files for this commit (must be before any step that uses its output)
    - name: Get changed files
      id: get_changed_files
      uses: tj-actions/changed-files@v44
      with:
        separator: ','

    # Remove older tags and releases if more than 50 exist (skip if workflow changed)
    - name: Remove older tags and releases if more than 50 exist (skip if workflow changed)
      if: github.ref == 'refs/heads/master' && !contains(join(steps.get_changed_files.outputs.all_changed_files, ','), '.github/workflows/dotnet-desktop.yml')
      id: remove_old_tags
      run: |
        $ErrorActionPreference = 'Stop'
        # Install GitHub CLI if not present
        if (-not (Get-Command gh -ErrorAction SilentlyContinue)) {
          Invoke-WebRequest -Uri "https://github.com/cli/cli/releases/download/v2.49.0/gh_2.49.0_windows_amd64.zip" -OutFile "ghcli.zip"
          Expand-Archive ghcli.zip -DestinationPath ghcli
          $env:Path += ";$pwd\ghcli\gh_2.49.0_windows_amd64\bin"
        }
        $tags = git tag --sort=-creatordate
        $tagCount = ($tags | Measure-Object -Line).Lines
        if ($tagCount -gt 50) {
          $tagsToDelete = $tags | Select-Object -Skip 50
          foreach ($tag in $tagsToDelete) {
            Write-Host "Deleting old tag: $tag"
            git tag -d $tag
            git push --delete origin $tag
            try {
              gh release delete $tag --yes
              Write-Host "Deleted release for tag: $tag"
            } catch {
              Write-Host "No release found for tag: $tag or failed to delete."
            }
          }
        } else {
          Write-Host "Tag count ($tagCount) is 50 or less. No tags or releases deleted."
        }
      shell: pwsh

    # Only create a release/tag if workflow file was not changed
    - name: Create an incremental release (skip if workflow changed)
      if: github.ref == 'refs/heads/master' && !contains(join(steps.get_changed_files.outputs.all_changed_files, ','), '.github/workflows/dotnet-desktop.yml')
      uses: aurestic/incrementarl-create-release@master
      with:
        flag_branch: true
        message: Bump version
        prev_tag: 'v'
        update_odoo_module_version: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    # Get Previous tag
    - name: 'Get Previous tag'
      id: currenttag
      uses: "WyriHaximus/github-action-get-previous-tag@v1"
      with:
        fallback: 1.0.0 # Optional fallback tag to use when no tag can be found
        #workingDirectory: another/path/where/a/git/repo/is/checked/out # Optional alternative working directory

  discover-test-projects:
    runs-on: ubuntu-latest
    outputs:
      test_projects: ${{ steps.find-tests.outputs.test_projects }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Find all test projects
        id: find-tests
        run: |
          # Find all .csproj files that look like test projects (by convention, in folders ending with 'Tests')
          TEST_PROJECTS=$(find . -type f -name "*.csproj" | grep -i 'Tests/' | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "Found test projects: $TEST_PROJECTS"
          echo "::notice::Discovered test projects: $TEST_PROJECTS"
          if [ "$TEST_PROJECTS" = "[]" ]; then
            echo "::error::No test projects discovered. Failing the job."
            exit 1
          fi
          echo "test_projects=$TEST_PROJECTS" >> $GITHUB_OUTPUT

  build-tests:
    needs: discover-test-projects
    runs-on: windows-latest
    outputs:
      test_projects: ${{ needs.discover-test-projects.outputs.test_projects }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Cache NuGet packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: ${{ runner.os }}-nuget-
      - name: Install .NET Core
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x
      - name: Setup MSBuild.exe
        uses: microsoft/setup-msbuild@v2
      - name: Restore all test projects
        run: |
          for proj in $(echo '${{ needs.discover-test-projects.outputs.test_projects }}' | jq -r '.[]'); do
            dotnet restore "$proj"
          done
        shell: bash
      - name: Build all test projects with error logging
        run: |
          set -e
          for proj in $(echo '${{ needs.discover-test-projects.outputs.test_projects }}' | jq -r '.[]'); do
            echo "Building $proj..."
            dotnet build "$proj" --configuration Debug --no-restore --output "$(dirname $proj)/bin/Debug" 2>&1 | tee "$(dirname $proj)/build.log"
          done
        shell: bash
      - name: Upload test build outputs
        uses: actions/upload-artifact@v4
        with:
          name: test-build-output
          path: |
            **/bin/Debug/
          retention-days: 2
      - name: Upload test build logs
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: test-build-logs
          path: '**/build.log'
          retention-days: 2

  run-tests:
    needs: [discover-test-projects, build-tests]
    if: needs.build-tests.result == 'success'
    strategy:
      matrix:
        test_project: ${{ fromJson(needs.discover-test-projects.outputs.test_projects) }}
    runs-on: windows-latest
    outputs:
      testresult: ${{ steps.testrun.outcome }}

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Cache NuGet packages
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: ${{ runner.os }}-nuget-

    - name: Install .NET Core
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x
    - name: Setup MSBuild.exe
      uses: microsoft/setup-msbuild@v2
    - name: Download test build outputs
      uses: actions/download-artifact@v4
      with:
        name: test-build-output
        path: ./
    - name: Run tests and collect coverage
      id: testrun
      run: |
        dotnet test ${{ matrix.test_project }} --configuration Debug --no-build --logger trx --collect:"XPlat Code Coverage"

    - name: Set Safe Artifact Name
      id: safe_name
      run: |
        SAFE_NAME="${{ matrix.test_project }}"
        SAFE_NAME="${SAFE_NAME//\//-}"
        SAFE_NAME="${SAFE_NAME//\\/-}"
        echo "safe_name=$SAFE_NAME" >> $GITHUB_OUTPUT

    - name: Upload Test Result Files
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ steps.safe_name.outputs.safe_name }}
        path: ${{ github.workspace }}/**/TestResults/**/*.trx
        retention-days: 5

    - name: Upload Coverage XML
      uses: actions/upload-artifact@v4
      with:
        name: coverage-${{ steps.safe_name.outputs.safe_name }}
        path: ${{ github.workspace }}/**/TestResults/**/coverage.cobertura.xml
        retention-days: 5


  test-publish:
    needs: run-tests
    strategy:
      matrix:
        configuration: [Debug]
    runs-on: ubuntu-latest

    steps:
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: coverage
      
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: coverage-summary
  

      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: test-results


      - name: Download all coverage artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: coverage-*
          path: coverage-artifacts

      - name: Merge coverage reports
        uses: danielpalme/ReportGenerator-GitHub-Action@5.3.5
        with:
          reports: 'coverage-artifacts/**/coverage.cobertura.xml'
          targetdir: 'merged-coverage'
          reporttypes: 'Cobertura;MarkdownSummary;Badges'

      - name: Publish Code Coverage Report
        uses: irongut/CodeCoverageSummary@v1.3.0
        with:
          filename: 'merged-coverage/Cobertura.xml'
          badge: true
          fail_below_min: false # just informative for now
          format: markdown
          hide_branch_rate: false
          hide_complexity: false
          indicators: true
          output: both
          thresholds: '10 30'

      - name: Write to Job Summary
        run: cat code-coverage-results.md >> $GITHUB_STEP_SUMMARY
    
      - name: Publish Test Results
        uses: EnricoMi/publish-unit-test-result-action@v2.16.1
        if: always()
        with:
          trx_files: "${{ github.workspace }}/**/*.trx"


  build:
    strategy:
      matrix:
        configuration: [Release, Debug]

    runs-on: windows-latest  # For a list of available runner types, refer to
                             # https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on

    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Cache NuGet packages
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: ${{ runner.os }}-nuget-

    - name: Restore dependencies
      run: dotnet restore ${{ env.Solution_Name }}

    - name: Build solution
      run: dotnet build ${{ env.Solution_Name }} --configuration ${{ matrix.configuration }} --no-restore

    - name: Publish FindNeedleUX (Release only)
      if: matrix.configuration == 'Release'
      run: dotnet publish ${{ env.FindNeedleUX_Project }} --configuration ${{ matrix.configuration }} --output ${{ github.workspace }}/publish

    - name: Archive Release (Release only)
      if: matrix.configuration == 'Release'
      uses: thedoctor0/zip-release@0.7.5
      with:
        type: 'zip'
        directory: '${{ github.workspace }}/publish'
        filename: 'release.zip'
        exclusions: '*.git* /*node_modules/*.editorconfig'

    - name: Upload Release bits (Release only)
      if: matrix.configuration == 'Release'
      uses: actions/upload-artifact@v4
      with:
        name: release-bits
        path: ${{ github.workspace }}/publish/release.zip
        retention-days: 5

  make_msix_signed:
    needs: [build]
    strategy:
      matrix:
        configuration: [Release]
    runs-on: windows-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Cache NuGet packages
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: ${{ runner.os }}-nuget-
    - name: Install .NET Core
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x
    - name: Setup MSBuild.exe
      uses: microsoft/setup-msbuild@v2
    - name: Download published output from build
      uses: actions/download-artifact@v4
      with:
        name: release-bits
        path: ${{ github.workspace }}/publish
    # Remove redundant restore/build steps, keep only MSIX-specific build/packaging
    - name: Restore NuGet packages for MSIX packaging
      run: dotnet restore ${{ env.FindNeedleUX_Project }}
    - name: Decode certificate from secret
      run: |
          [System.IO.File]::WriteAllBytes(
            "${{ github.workspace }}/FindNeedleUX/SigningCertificate.pfx",
            [System.Convert]::FromBase64String("${{ secrets.SIGNINGCERTIFICATEENCODED }}")
          )
      shell: pwsh
    - name: Import signing certificate to cert store
      id: import_cert
      run: |
        $pfxPath = "${{ github.workspace }}/FindNeedleUX/SigningCertificate.pfx"
        $securePassword = ConvertTo-SecureString "${{ secrets.SIGNINGCERTIFICATEPASSWORD }}" -AsPlainText -Force
        $cert = Import-PfxCertificate -FilePath $pfxPath -CertStoreLocation Cert:\CurrentUser\My -Password $securePassword
        echo "thumbprint=$($cert.Thumbprint)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
      shell: pwsh
    - name: Create MSIX package (signed)
      run: |
        msbuild ${{ env.FindNeedleUX_Project }} /m /p:Configuration=Release /p:UapAppxPackageBuildMode=StoreUpload /p:GenerateAppxPackageOnBuild=true /p:PackageCertificateThumbprint=${{ steps.import_cert.outputs.thumbprint }}
      shell: pwsh
    - name: Remove signing certificate from cert store
      if: always()
      run: |
        $thumb = "${{ steps.import_cert.outputs.thumbprint }}"
        if ($thumb) {
          $cert = Get-ChildItem -Path Cert:\CurrentUser\My | Where-Object { $_.Thumbprint -eq $thumb }
          if ($cert) {
            Remove-Item -Path $cert.PSPath -Force
            Write-Host "Removed certificate with thumbprint $thumb from store."
          } else {
            Write-Host "Certificate with thumbprint $thumb not found in store."
          }
        } else {
          Write-Host "No thumbprint found, skipping cert removal."
        }
      shell: pwsh
    - name: Upload MSIX artifact (signed)
      uses: actions/upload-artifact@v4
      with:
        name: FindNeedleUX-MSIX
        path: |
          **/AppPackages/**/*.msix
          **/AppPackages/**/*.msixbundle

  make_msix_unsigned:
    needs: [build]
    strategy:
      matrix:
        configuration: [Release]
    runs-on: windows-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Cache NuGet packages
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: ${{ runner.os }}-nuget-
    - name: Install .NET Core
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 8.0.x
    - name: Setup MSBuild.exe
      uses: microsoft/setup-msbuild@v2
    - name: Download published output from build
      uses: actions/download-artifact@v4
      with:
        name: release-bits
        path: ${{ github.workspace }}/publish
    # Remove redundant restore/build steps, keep only MSIX-specific build/packaging
    - name: Restore NuGet packages for MSIX packaging
      run: dotnet restore ${{ env.FindNeedleUX_Project }}
    - name: Create MSIX package (unsigned)
      run: |
        msbuild ${{ env.FindNeedleUX_Project }} /m /p:Configuration=Release /p:UapAppxPackageBuildMode=StoreUpload /p:GenerateAppxPackageOnBuild=true /p:AppxPackageSigningEnabled=false
      shell: pwsh
    - name: Upload MSIX artifact (unsigned)
      uses: actions/upload-artifact@v4
      with:
        name: FindNeedleUX-MSIX-unsigned
        path: |
          **/AppPackages/**/*.msix
          **/AppPackages/**/*.msixbundle


  actually_release:
    needs: [create-release, run-tests]
    strategy:
      matrix:
        configuration: [Release]

    runs-on: windows-latest  # For a list of available runner types, refer to
                           # https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on

    steps:
    - name: Check Test Results
      if: ${{ needs.run-tests.outputs.testresult != 'success' }}
      run: |
        echo "Tests failed. Failing the job."
        exit 1

    - name: Download release bits
      uses: actions/download-artifact@v4
      with:
        name: release-bits

    - name: Debug Release Tag
      run: "echo Release tag: ${{needs.create-release.outputs.releasetag}}"

    - name: Ensure release and tag do not already exist
      run: |
        # Install GitHub CLI if not present
        if ! command -v gh > /dev/null; then
          sudo apt-get update && sudo apt-get install -y gh
        fi
        TAG="${{needs.create-release.outputs.releasetag}}"
        if gh release view "$TAG" --repo "$GITHUB_REPOSITORY" > /dev/null 2>&1; then
          echo "Release with tag $TAG exists. Deleting..."
          gh release delete "$TAG" --yes --repo "$GITHUB_REPOSITORY"
        fi
        if git rev-parse "$TAG" >/dev/null 2>&1; then
          echo "Tag $TAG exists. Deleting..."
          git push --delete origin "$TAG" || true
          git tag -d "$TAG" || true
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GITHUB_REPOSITORY: ${{ github.repository }}
      shell: bash

    - name: Create Release
      id: create_release
      uses:  comnoco/create-release-action@v2.0.5
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{needs.create-release.outputs.releasetag}}
        release_name: Find Needle Beta ${{needs.create-release.outputs.releasetag}}
        draft: false
        prerelease: true
  
  
    - name: Upload Release Asset
      id: upload-release-asset 
      uses: sekwah41/upload-release-assets@v1.1.0
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: release-bits/release.zip
        asset_name: release.zip
        asset_content_type: application/zip


  update-badges:
    needs: run-tests
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download coverage badge artifact
        uses: actions/download-artifact@v4
        with:
          name: coverage-badge

      - name: Copy coverage badge to .github/badges/coverage.svg
        run: |
          mkdir -p .github/badges
          cp badge_linecoverage.svg .github/badges/coverage.svg

      - name: Commit and push coverage badge
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "github-actions@github.com"
          git fetch origin master
          git checkout master
          git add .github/badges/coverage.svg
          if git diff --cached --quiet; then
            echo "No changes to commit."
          else
            git commit -m "Update coverage badge [skip ci]"
            git push "https://${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" master
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}