# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# This workflow will build, test, sign and package a WPF or Windows Forms desktop application
# built on .NET Core.
# To learn how to migrate your existing application to .NET Core,
# refer to https://docs.microsoft.com/en-us/dotnet/desktop-wpf/migration/convert-project-from-net-framework
#
# To configure this workflow:
#
# 1. Configure environment variables
# GitHub sets default environment variables for every workflow run.
# Replace the variables relative to your project in the "env" section below.
#
# 2. Signing
# Generate a signing certificate in the Windows Application
# Packaging Project or add an existing signing certificate to the project.
# Next, use PowerShell to encode the .pfx file using Base64 encoding
# by running the following Powershell script to generate the output string:
#
# $pfx_cert = Get-Content '.\SigningCertificate.pfx' -Encoding Byte
# [System.Convert]::ToBase64String($pfx_cert) | Out-File 'SigningCertificate_Encoded.txt'
#
# Open the output file, SigningCertificate_Encoded.txt, and copy the
# string inside. Then, add the string to the repo as a GitHub secret
# and name it "Base64_Encoded_Pfx."
# For more information on how to configure your signing certificate for
# this workflow, refer to https://github.com/microsoft/github-actions-for-desktop-apps#signing
#
# Finally, add the signing certificate password to the repo as a secret and name it "Pfx_Key".
# See "Build the Windows Application Packaging project" below to see how the secret is used.
#
# For more information on GitHub Actions, refer to https://github.com/features/actions
# For a complete CI/CD sample to get started with GitHub Action workflows for Desktop Applications,
# refer to https://github.com/microsoft/github-actions-for-desktop-apps

name: .NET Core Desktop

permissions:
  contents: write

on:
  push:
    branches: [ "master" ]
    tags:
      - 'v*.*.*'

  pull_request:
    branches: [ "master" ]

env:
  Solution_Name: findneedle.sln
  FindNeedleUX_Project: FindNeedleUX/FindNeedleUX.csproj
  GH_TOKEN: ${{ github.token }}

jobs:
  create-release:
    needs: [build-release, run-tests]
    if: needs.run-tests.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      releasetag: ${{ steps.currenttag.outputs.tag }}

    steps:
    - name: Check Test Results
      run: |
        echo "Test results must be checked in the test job."

    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    # Get changed files for this commit (must be before any step that uses its output)
    - name: Get changed files
      id: get_changed_files
      uses: tj-actions/changed-files@v46
      with:
        separator: ','

    # Remove older tags and releases if more than 50 exist (skip if workflow changed)
    - name: Remove older tags and releases if more than 50 exist (skip if workflow changed)
      if: github.ref == 'refs/heads/master' && !contains(join(steps.get_changed_files.outputs.all_changed_files, ','), '.github/workflows/dotnet-desktop.yml')
      id: remove_old_tags
      run: |
        $ErrorActionPreference = 'Stop'
        # Install GitHub CLI if not present
        if (-not (Get-Command gh -ErrorAction SilentlyContinue)) {
          Invoke-WebRequest -Uri "https://github.com/cli/cli/releases/download/v2.49.0/gh_2.49.0_windows_amd64.zip" -OutFile "ghcli.zip"
          Expand-Archive ghcli.zip -DestinationPath ghcli
          $env:Path += ";$pwd\ghcli\gh_2.49.0_windows_amd64\bin"
        }
        $tags = git tag --sort=-creatordate
        $tagCount = ($tags | Measure-Object -Line).Lines
        if ($tagCount -gt 50) {
          $tagsToDelete = $tags | Select-Object -Skip 50
          foreach ($tag in $tagsToDelete) {
            Write-Host "Deleting old tag: $tag"
            git tag -d $tag
            git push --delete origin $tag
            try {
              gh release delete $tag --yes
              Write-Host "Deleted release for tag: $tag"
            } catch {
              Write-Host "No release found for tag: $tag or failed to delete."
            }
          }
        } else {
          Write-Host "Tag count ($tagCount) is 50 or less. No tags or releases deleted."
        }
      shell: pwsh

    # Only create a release/tag if workflow file was not changed
    - name: Create an incremental release (skip if workflow changed)
      if: github.ref == 'refs/heads/master' && !contains(join(steps.get_changed_files.outputs.all_changed_files, ','), '.github/workflows/dotnet-desktop.yml')
      uses: aurestic/incrementarl-create-release@master
      with:
        flag_branch: true
        message: Bump version
        prev_tag: 'v'
        update_odoo_module_version: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    # Get Previous tag
    - name: 'Get Previous tag'
      id: currenttag
      uses: "WyriHaximus/github-action-get-previous-tag@v1"
      with:
        fallback: 1.0.0 # Optional fallback tag to use when no tag can be found
        #workingDirectory: another/path/where/a/git/repo/is/checked/out # Optional alternative working directory

  discover-test-projects:
    runs-on: ubuntu-latest
    outputs:
      test_projects: ${{ steps.find-tests.outputs.test_projects }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Find all test projects
        id: find-tests
        run: |
          # Find all .csproj files that look like test projects (by convention, in folders ending with 'Tests')
          TEST_PROJECTS=$(find . -type f -name "*.csproj" | grep -i 'Tests/' | jq -R -s -c 'split("\n") | map(select(length > 0))')
          echo "Found test projects: $TEST_PROJECTS"
          echo "::notice::Discovered test projects: $TEST_PROJECTS"
          if [ "$TEST_PROJECTS" = "[]" ]; then
            echo "::error::No test projects discovered. Failing the job."
            exit 1
          fi
          echo "test_projects=$TEST_PROJECTS" >> $GITHUB_OUTPUT

  build-debug:
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Cache NuGet packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: ${{ runner.os }}-nuget-
      - name: Restore dependencies
        run: dotnet restore ${{ env.Solution_Name }}
      - name: Build solution (Debug)
        run: dotnet build ${{ env.Solution_Name }} --configuration Debug --no-restore
      - name: Publish all projects (Debug, x64)
        run: |
          for %%f in (*.csproj) do (
            for /f "usebackq tokens=*" %%t in (`powershell -Command "try { (Select-String -Path '%%f' -Pattern '<TargetFramework>(.+)</TargetFramework>' | Select-Object -First 1).Matches[0].Groups[1].Value } catch { '' }"`) do (
              if not "%%t"=="" dotnet publish "%%f" --configuration Debug --framework %%t --output "%%~dpfbin\x64\Debug\publish" --runtime win-x64 /p:Platform=x64
            )
          )
          for %%f in (*\*.csproj) do (
            for /f "usebackq tokens=*" %%t in (`powershell -Command "try { (Select-String -Path '%%f' -Pattern '<TargetFramework>(.+)</TargetFramework>' | Select-Object -First 1).Matches[0].Groups[1].Value } catch { '' }"`) do (
              if not "%%t"=="" dotnet publish "%%f" --configuration Debug --framework %%t --output "%%~dpfbin\x64\Debug\publish" --runtime win-x64 /p:Platform=x64
            )
          )
          for %%f in (*\*\*.csproj) do (
            for /f "usebackq tokens=*" %%t in (`powershell -Command "try { (Select-String -Path '%%f' -Pattern '<TargetFramework>(.+)</TargetFramework>' | Select-Object -First 1).Matches[0].Groups[1].Value } catch { '' }"`) do (
              if not "%%t"=="" dotnet publish "%%f" --configuration Debug --framework %%t --output "%%~dpfbin\x64\Debug\publish" --runtime win-x64 /p:Platform=x64
            )
          )
        shell: cmd
      - name: Build all test projects (Debug, x64)
        run: |
          for %%f in (*Tests/*.csproj) do dotnet build "%%f" --configuration Debug --no-restore --framework net9.0 --runtime win-x64 /p:Platform=x64
        shell: cmd
      - name: Upload all build outputs (Debug)
        uses: actions/upload-artifact@v4
        with:
          name: build-output-Debug
          path: .
          retention-days: 2

  build-release:
    runs-on: windows-latest
    strategy:
      matrix:
        platform: [x64]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Cache NuGet packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: ${{ runner.os }}-nuget-
      - name: Restore dependencies
        run: dotnet restore ${{ env.Solution_Name }}
      - name: Build solution (Release, ${{ matrix.platform }})
        run: dotnet build ${{ env.Solution_Name }} --configuration Release --no-restore /p:Platform=${{ matrix.platform }}
      - name: Publish FindNeedleUX (Release only, x64)
        if: matrix.platform == 'x64'
        run: dotnet publish ${{ env.FindNeedleUX_Project }} --configuration Release --output ${{ github.workspace }}/publish /p:Platform=x64
      - name: Archive Release (Release only, x64)
        if: matrix.platform == 'x64'
        uses: thedoctor0/zip-release@0.7.5
        with:
          type: 'zip'
          directory: '${{ github.workspace }}/publish'
          filename: 'release.zip'
          exclusions: '*.git* /*node_modules/*.editorconfig'
      - name: Upload Release bits (Release only, x64)
        if: matrix.platform == 'x64'
        uses: actions/upload-artifact@v4
        with:
          name: release-bits
          path: ${{ github.workspace }}/publish/release.zip
          retention-days: 5

  make_msix_signed:
    needs: [build-release]
    strategy:
      matrix:
        configuration: [Release]
    runs-on: windows-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Cache NuGet packages
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: ${{ runner.os }}-nuget-
    - name: Install .NET Core
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 9.0.x
    - name: Setup MSBuild.exe
      uses: microsoft/setup-msbuild@v2
    - name: Download published output from build
      uses: actions/download-artifact@v4
      with:
        name: release-bits
        path: ${{ github.workspace }}/publish
    # Remove redundant restore/build steps, keep only MSIX-specific build/packaging
    - name: Restore NuGet packages for MSIX packaging
      run: dotnet restore ${{ env.FindNeedleUX_Project }}
    - name: Decode certificate from secret
      run: |
          [System.IO.File]::WriteAllBytes(
            "${{ github.workspace }}/FindNeedleUX/SigningCertificate.pfx",
            [System.Convert]::FromBase64String("${{ secrets.SIGNINGCERTIFICATEENCODED }}")
          )
      shell: pwsh
    - name: Import signing certificate to cert store
      id: import_cert
      run: |
        $pfxPath = "${{ github.workspace }}/FindNeedleUX/SigningCertificate.pfx"
        $securePassword = ConvertTo-SecureString "${{ secrets.SIGNINGCERTIFICATEPASSWORD }}" -AsPlainText -Force
        $cert = Import-PfxCertificate -FilePath $pfxPath -CertStoreLocation Cert:\CurrentUser\My -Password $securePassword
        echo "thumbprint=$($cert.Thumbprint)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
      shell: pwsh
    - name: Create MSIX package (signed)
      run: |
        dotnet publish ${{ env.FindNeedleUX_Project }} --configuration Release --output ${{ github.workspace }}/publish /p:UapAppxPackageBuildMode=StoreUpload /p:GenerateAppxPackageOnBuild=true /p:PackageCertificateThumbprint=${{ steps.import_cert.outputs.thumbprint }}
      shell: pwsh
    - name: Remove signing certificate from cert store
      if: always()
      run: |
        $thumb = "${{ steps.import_cert.outputs.thumbprint }}"
        if ($thumb) {
          $cert = Get-ChildItem -Path Cert:\CurrentUser\My | Where-Object { $_.Thumbprint -eq $thumb }
          if ($cert) {
            Remove-Item -Path $cert.PSPath -Force
            Write-Host "Removed certificate with thumbprint $thumb from store."
          } else {
            Write-Host "Certificate with thumbprint $thumb not found in store."
          }
        } else {
          Write-Host "No thumbprint found, skipping cert removal."
        }
      shell: pwsh
    - name: Upload MSIX artifact (signed)
      uses: actions/upload-artifact@v4
      with:
        name: FindNeedleUX-MSIX
        path: |
          **/AppPackages/**/*.msix
          **/AppPackages/**/*.msixbundle

  make_msix_unsigned:
    needs: [build-release]
    strategy:
      matrix:
        configuration: [Release]
    runs-on: windows-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    - name: Cache NuGet packages
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        restore-keys: ${{ runner.os }}-nuget-
    - name: Install .NET Core
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: 9.0.x
    - name: Setup MSBuild.exe
      uses: microsoft/setup-msbuild@v2
    - name: Download published output from build
      uses: actions/download-artifact@v4
      with:
        name: release-bits
        path: ${{ github.workspace }}/publish
    # Remove redundant restore/build steps, keep only MSIX-specific build/packaging
    - name: Restore NuGet packages for MSIX packaging
      run: dotnet restore ${{ env.FindNeedleUX_Project }}
    - name: Create MSIX package (unsigned)
      run: |
        dotnet publish ${{ env.FindNeedleUX_Project }} --configuration Release --output ${{ github.workspace }}/publish /p:UapAppxPackageBuildMode=StoreUpload /p:GenerateAppxPackageOnBuild=true /p:AppxPackageSigningEnabled=false
      shell: pwsh
    - name: Upload MSIX artifact (unsigned)
      uses: actions/upload-artifact@v4
      with:
        name: FindNeedleUX-MSIX-unsigned
        path: |
          **/AppPackages/**/*.msix
          **/AppPackages/**/*.msixbundle


  actually_release:
    needs: [create-release]
    if: needs.create-release.result == 'success'
    strategy:
      matrix:
        configuration: [Release]

    runs-on: windows-latest  # For a list of available runner types, refer to
                           # https://help.github.com/en/actions/reference/workflow-syntax-for-github-actions#jobsjob_idruns-on

    steps:
    - name: Check Test Results
      run: |
        echo "Test results must be checked in the test job."

    - name: Download release bits
      uses: actions/download-artifact@v4
      with:
        name: release-bits

    - name: Debug Release Tag
      run: "echo Release tag: ${{needs.create-release.outputs.releasetag}}"

    - name: Ensure release and tag do not already exist
      run: |
        # Install GitHub CLI if not present
        if ! command -v gh > /dev/null; then
          sudo apt-get update && sudo apt-get install -y gh
        fi
        TAG="${{needs.create-release.outputs.releasetag}}"
        if gh release view "$TAG" --repo "$GITHUB_REPOSITORY" > /dev/null 2>&1; then
          echo "Release with tag $TAG exists. Deleting..."
          gh release delete "$TAG" --yes --repo "$GITHUB_REPOSITORY"
        fi
        if git rev-parse "$TAG" >/dev/null 2>&1; then
          echo "Tag $TAG exists. Deleting..."
          git push --delete origin "$TAG" || true
          git tag -d "$TAG" || true
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        GITHUB_REPOSITORY: ${{ github.repository }}
      shell: bash

    - name: Create Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{needs.create-release.outputs.releasetag}}
        release_name: Find Needle Beta ${{needs.create-release.outputs.releasetag}}
        draft: false
        prerelease: true
  
  
    - name: Upload Release Asset
      id: upload-release-asset 
      uses: sekwah41/upload-release-assets@v1.1.0
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ steps.create_release.outputs.upload_url }}
        asset_path: release-bits/release.zip
        asset_name: release.zip
        asset_content_type: application/zip


  update-badges:
    needs: run-tests
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master'
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download coverage badge artifact
        uses: actions/download-artifact@v4
        with:
          name: coverage-badge

      - name: Copy coverage badge to .github/badges/coverage.svg
        run: |
          mkdir -p .github/badges
          cp badge_linecoverage.svg .github/badges/coverage.svg

      - name: Commit and push coverage badge
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "github-actions@github.com"
          git fetch origin master
          git checkout master
          git add .github/badges/coverage.svg
          if git diff --cached --quiet; then
            echo "No changes to commit."
          else
            git commit -m "Update coverage badge [skip ci]"
            git push "https://${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git" master
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  run-tests:
    needs: [discover-test-projects, build-debug]
    if: needs.build-debug.result == 'success'
    strategy:
      matrix:
        test_project: ${{ fromJson(needs.discover-test-projects.outputs.test_projects) }}
    runs-on: windows-latest
    outputs:
      testresult: ${{ steps.testrun.outcome }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Cache NuGet packages
        uses: actions/cache@v3
        with:
          path: ~/.nuget/packages
          key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
          restore-keys: ${{ runner.os }}-nuget-
      - name: Install .NET Core
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.0.x
      - name: Setup MSBuild.exe
        uses: microsoft/setup-msbuild@v2
      - name: Download build outputs
        uses: actions/download-artifact@v4
        with:
          name: build-output-Debug
          path: .
      - name: Fail if test project does not exist
        shell: pwsh
        run: |
          if (-not (Test-Path "${{ matrix.test_project }}")) {
            Write-Host "Test project ${{ matrix.test_project }} was not built or does not exist. Failing."
            exit 1
          }
      - name: Run tests and collect coverage
        id: testrun
        run: |
          dotnet test ${{ matrix.test_project }} --configuration Debug --no-build --logger trx --collect:"XPlat Code Coverage" --runtime win-x64 /p:Platform=x64
      - name: Set Safe Artifact Name
        id: safe_name
        run: |
          SAFE_NAME="${{ matrix.test_project }}"
          SAFE_NAME="${SAFE_NAME//\//-}"
          SAFE_NAME="${SAFE_NAME//\\/-}"
          echo "safe_name=$SAFE_NAME" >> $GITHUB_OUTPUT
      - name: Upload Test Result Files
        uses: actions/upload-artifact@v4
        with:
          name: test-results-${{ steps.safe_name.outputs.safe_name }}
          path: ${{ github.workspace }}/**/TestResults/**/*.trx
          retention-days: 5
      - name: Upload Coverage XML
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ steps.safe_name.outputs.safe_name }}
          path: ${{ github.workspace }}/**/TestResults/**/coverage.cobertura.xml
          retention-days: 5